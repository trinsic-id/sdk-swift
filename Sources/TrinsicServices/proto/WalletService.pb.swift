// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: WalletService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Trinsic_Services_CreateWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var controller: String = String()

  public var description_p: String = String()

  /// (Optional) Supply an invitation id to associate this caller profile
  /// to an existing cloud wallet.
  public var securityCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_CreateWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Trinsic_Services_ResponseStatus = .success

  public var walletID: String = String()

  public var capability: String = String()

  public var invoker: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contactMethod: Trinsic_Services_ConnectRequest.OneOf_ContactMethod? = nil

  public var email: String {
    get {
      if case .email(let v)? = contactMethod {return v}
      return String()
    }
    set {contactMethod = .email(newValue)}
  }

  public var phone: String {
    get {
      if case .phone(let v)? = contactMethod {return v}
      return String()
    }
    set {contactMethod = .phone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ContactMethod: Equatable {
    case email(String)
    case phone(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Trinsic_Services_ConnectRequest.OneOf_ContactMethod, rhs: Trinsic_Services_ConnectRequest.OneOf_ContactMethod) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.email, .email): return {
        guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Trinsic_Services_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Trinsic_Services_ResponseStatus = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_InvitationToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var securityCode: String = String()

  public var walletID: String = String()

  public var contactMethod: Trinsic_Services_InvitationToken.OneOf_ContactMethod? = nil

  public var email: String {
    get {
      if case .email(let v)? = contactMethod {return v}
      return String()
    }
    set {contactMethod = .email(newValue)}
  }

  public var phone: String {
    get {
      if case .phone(let v)? = contactMethod {return v}
      return String()
    }
    set {contactMethod = .phone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ContactMethod: Equatable {
    case email(String)
    case phone(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Trinsic_Services_InvitationToken.OneOf_ContactMethod, rhs: Trinsic_Services_InvitationToken.OneOf_ContactMethod) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.email, .email): return {
        guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
///Stores profile data for accessing a wallet.
///This result should be stored somewhere safe,
///as it contains private key information.
public struct Trinsic_Services_WalletProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var didDocument: Trinsic_Services_JsonPayload {
    get {return _didDocument ?? Trinsic_Services_JsonPayload()}
    set {_didDocument = newValue}
  }
  /// Returns true if `didDocument` has been explicitly set.
  public var hasDidDocument: Bool {return self._didDocument != nil}
  /// Clears the value of `didDocument`. Subsequent reads from it will return its default value.
  public mutating func clearDidDocument() {self._didDocument = nil}

  public var walletID: String = String()

  public var invoker: String = String()

  public var capability: String = String()

  public var invokerJwk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _didDocument: Trinsic_Services_JsonPayload? = nil
}

public struct Trinsic_Services_GrantAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var walletID: String = String()

  public var did: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_GrantAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Trinsic_Services_ResponseStatus = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_RevokeAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var walletID: String = String()

  public var did: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_RevokeAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Trinsic_Services_ResponseStatus = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_GetProviderConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var didDocument: Trinsic_Services_JsonPayload {
    get {return _didDocument ?? Trinsic_Services_JsonPayload()}
    set {_didDocument = newValue}
  }
  /// Returns true if `didDocument` has been explicitly set.
  public var hasDidDocument: Bool {return self._didDocument != nil}
  /// Clears the value of `didDocument`. Subsequent reads from it will return its default value.
  public mutating func clearDidDocument() {self._didDocument = nil}

  public var keyAgreementKeyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _didDocument: Trinsic_Services_JsonPayload? = nil
}

public struct Trinsic_Services_SearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var continuationToken: String = String()

  public var options: Trinsic_Services_RequestOptions {
    get {return _options ?? Trinsic_Services_RequestOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Trinsic_Services_RequestOptions? = nil
}

public struct Trinsic_Services_SearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Trinsic_Services_JsonPayload] = []

  public var hasMore_p: Bool = false

  public var count: Int32 = 0

  public var continuationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Trinsic_Services_InsertItemRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Trinsic_Services_JsonPayload {
    get {return _item ?? Trinsic_Services_JsonPayload()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var itemType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Trinsic_Services_JsonPayload? = nil
}

public struct Trinsic_Services_InsertItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Trinsic_Services_ResponseStatus = .success

  public var itemID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "trinsic.services"

extension Trinsic_Services_CreateWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWalletRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "controller"),
    2: .same(proto: "description"),
    3: .standard(proto: "security_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.controller) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.controller.isEmpty {
      try visitor.visitSingularStringField(value: self.controller, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_CreateWalletRequest, rhs: Trinsic_Services_CreateWalletRequest) -> Bool {
    if lhs.controller != rhs.controller {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_CreateWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWalletResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "wallet_id"),
    3: .same(proto: "capability"),
    4: .same(proto: "invoker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.walletID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.capability) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.invoker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.walletID.isEmpty {
      try visitor.visitSingularStringField(value: self.walletID, fieldNumber: 2)
    }
    if !self.capability.isEmpty {
      try visitor.visitSingularStringField(value: self.capability, fieldNumber: 3)
    }
    if !self.invoker.isEmpty {
      try visitor.visitSingularStringField(value: self.invoker, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_CreateWalletResponse, rhs: Trinsic_Services_CreateWalletResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.walletID != rhs.walletID {return false}
    if lhs.capability != rhs.capability {return false}
    if lhs.invoker != rhs.invoker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "email"),
    6: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.contactMethod != nil {try decoder.handleConflictingOneOf()}
          self.contactMethod = .email(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.contactMethod != nil {try decoder.handleConflictingOneOf()}
          self.contactMethod = .phone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.contactMethod {
    case .email?: try {
      guard case .email(let v)? = self.contactMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .phone?: try {
      guard case .phone(let v)? = self.contactMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_ConnectRequest, rhs: Trinsic_Services_ConnectRequest) -> Bool {
    if lhs.contactMethod != rhs.contactMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_ConnectResponse, rhs: Trinsic_Services_ConnectResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_InvitationToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitationToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "security_code"),
    2: .standard(proto: "wallet_id"),
    5: .same(proto: "email"),
    6: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.walletID) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.contactMethod != nil {try decoder.handleConflictingOneOf()}
          self.contactMethod = .email(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.contactMethod != nil {try decoder.handleConflictingOneOf()}
          self.contactMethod = .phone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 1)
    }
    if !self.walletID.isEmpty {
      try visitor.visitSingularStringField(value: self.walletID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.contactMethod {
    case .email?: try {
      guard case .email(let v)? = self.contactMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .phone?: try {
      guard case .phone(let v)? = self.contactMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_InvitationToken, rhs: Trinsic_Services_InvitationToken) -> Bool {
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.walletID != rhs.walletID {return false}
    if lhs.contactMethod != rhs.contactMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_WalletProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "did_document"),
    2: .standard(proto: "wallet_id"),
    3: .same(proto: "invoker"),
    4: .same(proto: "capability"),
    5: .standard(proto: "invoker_jwk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._didDocument) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.walletID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.invoker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.capability) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.invokerJwk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._didDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.walletID.isEmpty {
      try visitor.visitSingularStringField(value: self.walletID, fieldNumber: 2)
    }
    if !self.invoker.isEmpty {
      try visitor.visitSingularStringField(value: self.invoker, fieldNumber: 3)
    }
    if !self.capability.isEmpty {
      try visitor.visitSingularStringField(value: self.capability, fieldNumber: 4)
    }
    if !self.invokerJwk.isEmpty {
      try visitor.visitSingularBytesField(value: self.invokerJwk, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_WalletProfile, rhs: Trinsic_Services_WalletProfile) -> Bool {
    if lhs._didDocument != rhs._didDocument {return false}
    if lhs.walletID != rhs.walletID {return false}
    if lhs.invoker != rhs.invoker {return false}
    if lhs.capability != rhs.capability {return false}
    if lhs.invokerJwk != rhs.invokerJwk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_GrantAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantAccessRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_id"),
    2: .same(proto: "did"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.walletID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.did) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletID.isEmpty {
      try visitor.visitSingularStringField(value: self.walletID, fieldNumber: 1)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_GrantAccessRequest, rhs: Trinsic_Services_GrantAccessRequest) -> Bool {
    if lhs.walletID != rhs.walletID {return false}
    if lhs.did != rhs.did {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_GrantAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantAccessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_GrantAccessResponse, rhs: Trinsic_Services_GrantAccessResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_RevokeAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeAccessRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_id"),
    2: .same(proto: "did"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.walletID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.did) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletID.isEmpty {
      try visitor.visitSingularStringField(value: self.walletID, fieldNumber: 1)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_RevokeAccessRequest, rhs: Trinsic_Services_RevokeAccessRequest) -> Bool {
    if lhs.walletID != rhs.walletID {return false}
    if lhs.did != rhs.did {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_RevokeAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeAccessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_RevokeAccessResponse, rhs: Trinsic_Services_RevokeAccessResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_GetProviderConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProviderConfigurationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "did_document"),
    2: .standard(proto: "key_agreement_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._didDocument) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyAgreementKeyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._didDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.keyAgreementKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyAgreementKeyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_GetProviderConfigurationResponse, rhs: Trinsic_Services_GetProviderConfigurationResponse) -> Bool {
    if lhs._didDocument != rhs._didDocument {return false}
    if lhs.keyAgreementKeyID != rhs.keyAgreementKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_SearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .standard(proto: "continuation_token"),
    5: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.continuationToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if !self.continuationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.continuationToken, fieldNumber: 2)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_SearchRequest, rhs: Trinsic_Services_SearchRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.continuationToken != rhs.continuationToken {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_SearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .standard(proto: "has_more"),
    3: .same(proto: "count"),
    4: .standard(proto: "continuation_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.continuationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    if !self.continuationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.continuationToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_SearchResponse, rhs: Trinsic_Services_SearchResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.count != rhs.count {return false}
    if lhs.continuationToken != rhs.continuationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_InsertItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InsertItemRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .standard(proto: "item_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.itemType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.itemType.isEmpty {
      try visitor.visitSingularStringField(value: self.itemType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_InsertItemRequest, rhs: Trinsic_Services_InsertItemRequest) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.itemType != rhs.itemType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trinsic_Services_InsertItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InsertItemResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "item_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trinsic_Services_InsertItemResponse, rhs: Trinsic_Services_InsertItemResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

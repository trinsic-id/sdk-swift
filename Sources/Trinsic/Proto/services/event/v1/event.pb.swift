// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/event/v1/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// All event types
public enum Trinsic_Services_Event_EventType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ping // = 0
    case log // = 1
    case egfCreated // = 5
    case egfMemberRegistered // = 6
    case egfMemberUnregistered // = 7
    case templateCreated // = 10
    case templateDeleted // = 11
    case walletCreated // = 15
    case itemReceived // = 16
    case UNRECOGNIZED(Int)

    public init() {
        self = .ping
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ping
        case 1: self = .log
        case 5: self = .egfCreated
        case 6: self = .egfMemberRegistered
        case 7: self = .egfMemberUnregistered
        case 10: self = .templateCreated
        case 11: self = .templateDeleted
        case 15: self = .walletCreated
        case 16: self = .itemReceived
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .ping: return 0
        case .log: return 1
        case .egfCreated: return 5
        case .egfMemberRegistered: return 6
        case .egfMemberUnregistered: return 7
        case .templateCreated: return 10
        case .templateDeleted: return 11
        case .walletCreated: return 15
        case .itemReceived: return 16
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Trinsic_Services_Event_EventType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [Trinsic_Services_Event_EventType] = [
            .ping,
            .log,
            .egfCreated,
            .egfMemberRegistered,
            .egfMemberUnregistered,
            .templateCreated,
            .templateDeleted,
            .walletCreated,
            .itemReceived,
        ]
    }

#endif // swift(>=4.2)

/// Event
public struct Trinsic_Services_Event_Event {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of event
    public var id: String = .init()

    /// Type of event
    public var type: Trinsic_Services_Event_EventType = .ping

    /// Timestamp event occurred, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)
    public var timestamp: String = .init()

    /// Event-specific payload, as an encoded protobuf message
    public var data: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Trinsic_Services_Event_APICall {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var source: String = .init()

    public var request: Data = .init()

    public var response: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Webhook test event
public struct Trinsic_Services_Event_Ping {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of this ping
    public var id: String = .init()

    /// UUID of the webhook receiving the ping
    public var webhookID: String = .init()

    /// Timestamp ping was requested, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)
    public var timestamp: String = .init()

    /// Arbitrary message specified when ping was requested
    public var message: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Entity Governance Framework created and attached to ecosystem
public struct Trinsic_Services_Event_EGFCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of the governance framework
    public var id: String = .init()

    /// UUID of the ecosystem that owns this EGF
    public var ecosystemID: String = .init()

    /// Trust registry associated with this EGF
    public var trustRegistry: String = .init()

    /// Wallet ID of the authority for this EGF
    public var governingAuthority: String = .init()

    /// Type of EGF
    public var type: String = .init()

    /// User-friendly name for the EGF
    public var name: String = .init()

    /// Description of the EGF
    public var description_p: String = .init()

    /// URI for the EGF
    public var governanceFramework: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Template created in ecosystem
public struct Trinsic_Services_Event_TemplateCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of the template
    public var id: String = .init()

    /// UUID of the ecosystem that owns this template
    public var ecosystemID: String = .init()

    /// Template name
    public var name: String = .init()

    /// Template type
    public var type: String = .init()

    /// WalletID that created the template
    public var createdBy: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Item inserted into wallet
public struct Trinsic_Services_Event_ItemReceived {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of the new item
    public var id: String = .init()

    /// Timestamp when the item was received, in ISO 8601 format (ex. `2022-07-07T08:09:10.11Z`)
    public var received: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Trinsic_Services_Event_EventType: @unchecked Sendable {}
    extension Trinsic_Services_Event_Event: @unchecked Sendable {}
    extension Trinsic_Services_Event_APICall: @unchecked Sendable {}
    extension Trinsic_Services_Event_Ping: @unchecked Sendable {}
    extension Trinsic_Services_Event_EGFCreated: @unchecked Sendable {}
    extension Trinsic_Services_Event_TemplateCreated: @unchecked Sendable {}
    extension Trinsic_Services_Event_ItemReceived: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Extension support defined in event.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

public extension SwiftProtobuf.Google_Protobuf_MessageOptions {
    /// Event type associated with this Event message.
    var Trinsic_Services_Event_eventType: Trinsic_Services_Event_EventType {
        get { return getExtensionValue(ext: Trinsic_Services_Event_Extensions_event_type) ?? .ping }
        set { setExtensionValue(ext: Trinsic_Services_Event_Extensions_event_type, value: newValue) }
    }

    /// Returns true if extension `Trinsic_Services_Event_Extensions_event_type`
    /// has been explicitly set.
    var hasTrinsic_Services_Event_eventType: Bool {
        return hasExtensionValue(ext: Trinsic_Services_Event_Extensions_event_type)
    }

    /// Clears the value of extension `Trinsic_Services_Event_Extensions_event_type`.
    /// Subsequent reads from it will return its default value.
    mutating func clearTrinsic_Services_Event_eventType() {
        clearExtensionValue(ext: Trinsic_Services_Event_Extensions_event_type)
    }
}

// MARK: - File's ExtensionMap: Trinsic_Services_Event_Event_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Trinsic_Services_Event_Event_Extensions: SwiftProtobuf.SimpleExtensionMap = [
    Trinsic_Services_Event_Extensions_event_type,
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// Event type associated with this Event message.
public let Trinsic_Services_Event_Extensions_event_type = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalEnumExtensionField<Trinsic_Services_Event_EventType>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
    _protobuf_fieldNumber: 60002,
    fieldName: "trinsic.services.event.event_type"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "trinsic.services.event"

extension Trinsic_Services_Event_EventType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "PING"),
        1: .same(proto: "LOG"),
        5: .same(proto: "EGF_CREATED"),
        6: .same(proto: "EGF_MEMBER_REGISTERED"),
        7: .same(proto: "EGF_MEMBER_UNREGISTERED"),
        10: .same(proto: "TEMPLATE_CREATED"),
        11: .same(proto: "TEMPLATE_DELETED"),
        15: .same(proto: "WALLET_CREATED"),
        16: .same(proto: "ITEM_RECEIVED"),
    ]
}

extension Trinsic_Services_Event_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Event"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "type"),
        3: .same(proto: "timestamp"),
        4: .same(proto: "data"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularEnumField(value: &type)
            case 3: try try decoder.decodeSingularStringField(value: &timestamp)
            case 4: try try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if type != .ping {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        if !timestamp.isEmpty {
            try visitor.visitSingularStringField(value: timestamp, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_Event, rhs: Trinsic_Services_Event_Event) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.type != rhs.type { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Trinsic_Services_Event_APICall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".APICall"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "source"),
        2: .same(proto: "request"),
        3: .same(proto: "response"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &source)
            case 2: try try decoder.decodeSingularBytesField(value: &request)
            case 3: try try decoder.decodeSingularBytesField(value: &response)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !source.isEmpty {
            try visitor.visitSingularStringField(value: source, fieldNumber: 1)
        }
        if !request.isEmpty {
            try visitor.visitSingularBytesField(value: request, fieldNumber: 2)
        }
        if !response.isEmpty {
            try visitor.visitSingularBytesField(value: response, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_APICall, rhs: Trinsic_Services_Event_APICall) -> Bool {
        if lhs.source != rhs.source { return false }
        if lhs.request != rhs.request { return false }
        if lhs.response != rhs.response { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Trinsic_Services_Event_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Ping"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "webhook_id"),
        3: .same(proto: "timestamp"),
        4: .same(proto: "message"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &webhookID)
            case 3: try try decoder.decodeSingularStringField(value: &timestamp)
            case 4: try try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !webhookID.isEmpty {
            try visitor.visitSingularStringField(value: webhookID, fieldNumber: 2)
        }
        if !timestamp.isEmpty {
            try visitor.visitSingularStringField(value: timestamp, fieldNumber: 3)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_Ping, rhs: Trinsic_Services_Event_Ping) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.webhookID != rhs.webhookID { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Trinsic_Services_Event_EGFCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EGFCreated"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "ecosystem_id"),
        3: .standard(proto: "trust_registry"),
        4: .standard(proto: "governing_authority"),
        5: .same(proto: "type"),
        6: .same(proto: "name"),
        7: .same(proto: "description"),
        8: .standard(proto: "governance_framework"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &ecosystemID)
            case 3: try try decoder.decodeSingularStringField(value: &trustRegistry)
            case 4: try try decoder.decodeSingularStringField(value: &governingAuthority)
            case 5: try try decoder.decodeSingularStringField(value: &type)
            case 6: try try decoder.decodeSingularStringField(value: &name)
            case 7: try try decoder.decodeSingularStringField(value: &description_p)
            case 8: try try decoder.decodeSingularStringField(value: &governanceFramework)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 2)
        }
        if !trustRegistry.isEmpty {
            try visitor.visitSingularStringField(value: trustRegistry, fieldNumber: 3)
        }
        if !governingAuthority.isEmpty {
            try visitor.visitSingularStringField(value: governingAuthority, fieldNumber: 4)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 5)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 6)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 7)
        }
        if !governanceFramework.isEmpty {
            try visitor.visitSingularStringField(value: governanceFramework, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_EGFCreated, rhs: Trinsic_Services_Event_EGFCreated) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.trustRegistry != rhs.trustRegistry { return false }
        if lhs.governingAuthority != rhs.governingAuthority { return false }
        if lhs.type != rhs.type { return false }
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.governanceFramework != rhs.governanceFramework { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Trinsic_Services_Event_TemplateCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TemplateCreated"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "ecosystem_id"),
        3: .same(proto: "name"),
        4: .same(proto: "type"),
        5: .standard(proto: "created_by"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &ecosystemID)
            case 3: try try decoder.decodeSingularStringField(value: &name)
            case 4: try try decoder.decodeSingularStringField(value: &type)
            case 5: try try decoder.decodeSingularStringField(value: &createdBy)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 2)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 3)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 4)
        }
        if !createdBy.isEmpty {
            try visitor.visitSingularStringField(value: createdBy, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_TemplateCreated, rhs: Trinsic_Services_Event_TemplateCreated) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.name != rhs.name { return false }
        if lhs.type != rhs.type { return false }
        if lhs.createdBy != rhs.createdBy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Trinsic_Services_Event_ItemReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ItemReceived"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "received"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &received)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !received.isEmpty {
            try visitor.visitSingularStringField(value: received, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Trinsic_Services_Event_ItemReceived, rhs: Trinsic_Services_Event_ItemReceived) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.received != rhs.received { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/provider/v1/provider.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum Services_Provider_V1_IdentityProvider: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Identity provider is unknown
    case unknown // = 0

    /// Identity provider is email
    case email // = 1

    /// Identity provider is phone
    case phone // = 2

    /// Identity provider is passkey (WebAuthn) -- for Trinsic internal use only
    case passkey // = 3

    /// Identity provider is passkey using Trinsic Authenticator for mobile phones
    case trinsicAuthenticator // = 4
    case UNRECOGNIZED(Int)

    public init() {
        self = .unknown
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .email
        case 2: self = .phone
        case 3: self = .passkey
        case 4: self = .trinsicAuthenticator
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .email: return 1
        case .phone: return 2
        case .passkey: return 3
        case .trinsicAuthenticator: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Provider_V1_IdentityProvider: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Provider_V1_IdentityProvider] = [
            .unknown,
            .email,
            .phone,
            .passkey,
            .trinsicAuthenticator,
        ]
    }

#endif // swift(>=4.2)

/// Details of an ecosystem
public struct Services_Provider_V1_Ecosystem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URN of the ecosystem
    public var id: String = .init()

    /// Globally unique name for the ecosystem
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to create an ecosystem
public struct Services_Provider_V1_CreateEcosystemRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Globally unique name for the Ecosystem. This name will be
    /// part of the ecosystem-specific URLs and namespaces.
    /// Allowed characters are lowercase letters, numbers, underscore and hyphen.
    /// If not passed, ecosystem name will be auto-generated.
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    /// The account details of the owner of the ecosystem
    public var details: Services_Account_V1_AccountDetails {
        get { _details ?? Services_Account_V1_AccountDetails() }
        set { _details = newValue }
    }

    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool { _details != nil }
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() { _details = nil }

    /// New domain URL
    public var domain: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _details: Services_Account_V1_AccountDetails?
}

/// Response to `CreateEcosystemRequest`
public struct Services_Provider_V1_CreateEcosystemResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Details of the created ecosystem
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    /// Account profile for auth of the owner of the ecosystem
    public var profile: Services_Account_V1_AccountProfile {
        get { _profile ?? Services_Account_V1_AccountProfile() }
        set { _profile = newValue }
    }

    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool { _profile != nil }
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() { _profile = nil }

    /// Indicates if confirmation of account is required.
    public var confirmationMethod: Services_Account_V1_ConfirmationMethod = .none

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
    private var _profile: Services_Account_V1_AccountProfile?
}

/// Request to fetch information about an ecosystem
public struct Services_Provider_V1_EcosystemInfoRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `InfoRequest`
public struct Services_Provider_V1_EcosystemInfoResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem corresponding to current ecosystem in the account token
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to fetch the Trinsic public key used
/// to verify authentication token validity
public struct Services_Provider_V1_GetOberonKeyRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `GetOberonKeyRequest`
public struct Services_Provider_V1_GetOberonKeyResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Oberon Public Key as RAW base64-url encoded string
    public var key: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Search for issuers/holders/verifiers
public struct Services_Provider_V1_SearchWalletConfigurationsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SQL filter to execute. `SELECT * FROM c WHERE [**queryFilter**]`
    public var queryFilter: String = .init()

    /// Token provided by previous `SearchResponse`
    /// if more data is available for query
    public var continuationToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_SearchWalletConfigurationResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Results matching the search query
    public var results: [Services_Provider_V1_WalletConfiguration] = []

    /// Whether more results are available for this query via `continuation_token`
    public var hasMoreResults_p: Bool = false

    /// Token to fetch next set of results via `SearchRequest`
    public var continuationToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Strongly typed information about wallet configurations
public struct Services_Provider_V1_WalletConfiguration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name/description of the wallet
    public var name: String = .init()

    /// Deprecated and will be removed on August 1, 2023 -- use external_identities.
    /// This field is set to the first email address present in `external_identities`, if any.
    public var email: String = .init()

    /// Deprecated -- use external_identities
    public var sms: String = .init()

    public var walletID: String = .init()

    /// The DID of the wallet
    public var publicDid: String = .init()

    public var configType: String = .init()

    /// List of active authentication tokens for this wallet.
    /// This list does not contain the issued token, only metadata
    /// such as ID, description, and creation date.
    public var authTokens: [Services_Account_V1_WalletAuthToken] = []

    /// List of external identity IDs (email addresses, phone numbers, etc.) associated with this wallet.
    /// This is deprecated; use `external_identities` instead.
    public var externalIdentityIds: [String] = []

    /// Ecosystem in which this wallet is contained.
    public var ecosystemID: String = .init()

    public var description_p: String = .init()

    /// List of external identities associated with this wallet.
    public var externalIdentities: [Services_Provider_V1_WalletExternalIdentity] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// An external identity (email address, phone number, etc.) associated with a wallet for authentication purposes.
public struct Services_Provider_V1_WalletExternalIdentity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of this identity (whether this identity is an email address, phone number, etc.)
    public var provider: Services_Provider_V1_IdentityProvider = .unknown

    /// The actual email address/phone number/etc. for this identity
    public var id: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Options for creation of DID on the ION network
public struct Services_Provider_V1_IonOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ION network on which DID should be published
    public var network: Services_Provider_V1_IonOptions.IonNetwork = .testNet

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum IonNetwork: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case testNet // = 0
        case mainNet // = 1
        case UNRECOGNIZED(Int)

        public init() {
            self = .testNet
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .testNet
            case 1: self = .mainNet
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .testNet: return 0
            case .mainNet: return 1
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension Services_Provider_V1_IonOptions.IonNetwork: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Provider_V1_IonOptions.IonNetwork] = [
            .testNet,
            .mainNet,
        ]
    }

#endif // swift(>=4.2)

/// Options for creation of DID on the SOV network
public struct Services_Provider_V1_IndyOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SOV network on which DID should be published
    public var network: Services_Provider_V1_IndyOptions.IndyNetwork = .danube

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum IndyNetwork: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case danube // = 0
        case sovrinBuilder // = 1
        case sovrinStaging // = 2
        case sovrin // = 3
        case idUnionTest // = 4
        case idUnion // = 5
        case indicioTest // = 6
        case indicioDemo // = 7
        case indicio // = 8
        case UNRECOGNIZED(Int)

        public init() {
            self = .danube
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .danube
            case 1: self = .sovrinBuilder
            case 2: self = .sovrinStaging
            case 3: self = .sovrin
            case 4: self = .idUnionTest
            case 5: self = .idUnion
            case 6: self = .indicioTest
            case 7: self = .indicioDemo
            case 8: self = .indicio
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .danube: return 0
            case .sovrinBuilder: return 1
            case .sovrinStaging: return 2
            case .sovrin: return 3
            case .idUnionTest: return 4
            case .idUnion: return 5
            case .indicioTest: return 6
            case .indicioDemo: return 7
            case .indicio: return 8
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension Services_Provider_V1_IndyOptions.IndyNetwork: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Provider_V1_IndyOptions.IndyNetwork] = [
            .danube,
            .sovrinBuilder,
            .sovrinStaging,
            .sovrin,
            .idUnionTest,
            .idUnion,
            .indicioTest,
            .indicioDemo,
            .indicio,
        ]
    }

#endif // swift(>=4.2)

/// Request to upgrade a wallet
public struct Services_Provider_V1_UpgradeDidRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var account: Services_Provider_V1_UpgradeDidRequest.OneOf_Account?

    /// Email address of account to upgrade.
    /// Mutually exclusive with `walletId` and `didUri`.
    public var email: String {
        get {
            if case let .email(v)? = account { return v }
            return String()
        }
        set { account = .email(newValue) }
    }

    /// Wallet ID of account to upgrade.
    /// Mutually exclusive with `email` and `didUri`.
    public var walletID: String {
        get {
            if case let .walletID(v)? = account { return v }
            return String()
        }
        set { account = .walletID(newValue) }
    }

    /// DID URI of the account to upgrade.
    /// Mutually exclusive with `email` and `walletId`.
    public var didUri: String {
        get {
            if case let .didUri(v)? = account { return v }
            return String()
        }
        set { account = .didUri(newValue) }
    }

    /// DID Method to which wallet should be upgraded
    public var method: Services_Common_V1_SupportedDidMethod = .key

    public var options: Services_Provider_V1_UpgradeDidRequest.OneOf_Options?

    /// Configuration for creation of DID on ION network
    public var ionOptions: Services_Provider_V1_IonOptions {
        get {
            if case let .ionOptions(v)? = options { return v }
            return Services_Provider_V1_IonOptions()
        }
        set { options = .ionOptions(newValue) }
    }

    /// Configuration for creation of DID on INDY network
    public var indyOptions: Services_Provider_V1_IndyOptions {
        get {
            if case let .indyOptions(v)? = options { return v }
            return Services_Provider_V1_IndyOptions()
        }
        set { options = .indyOptions(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Account: Equatable {
        /// Email address of account to upgrade.
        /// Mutually exclusive with `walletId` and `didUri`.
        case email(String)
        /// Wallet ID of account to upgrade.
        /// Mutually exclusive with `email` and `didUri`.
        case walletID(String)
        /// DID URI of the account to upgrade.
        /// Mutually exclusive with `email` and `walletId`.
        case didUri(String)

        #if !swift(>=4.1)
            public static func == (lhs: Services_Provider_V1_UpgradeDidRequest.OneOf_Account, rhs: Services_Provider_V1_UpgradeDidRequest.OneOf_Account) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.email, .email): return {
                        guard case let .email(l) = lhs, case let .email(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.walletID, .walletID): return {
                        guard case let .walletID(l) = lhs, case let .walletID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.didUri, .didUri): return {
                        guard case let .didUri(l) = lhs, case let .didUri(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public enum OneOf_Options: Equatable {
        /// Configuration for creation of DID on ION network
        case ionOptions(Services_Provider_V1_IonOptions)
        /// Configuration for creation of DID on INDY network
        case indyOptions(Services_Provider_V1_IndyOptions)

        #if !swift(>=4.1)
            public static func == (lhs: Services_Provider_V1_UpgradeDidRequest.OneOf_Options, rhs: Services_Provider_V1_UpgradeDidRequest.OneOf_Options) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.ionOptions, .ionOptions): return {
                        guard case let .ionOptions(l) = lhs, case let .ionOptions(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.indyOptions, .indyOptions): return {
                        guard case let .indyOptions(l) = lhs, case let .indyOptions(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

/// Response to `UpgradeDIDRequest`
public struct Services_Provider_V1_UpgradeDidResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// New DID of wallet
    public var did: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Services_Provider_V1_IdentityProvider: @unchecked Sendable {}
    extension Services_Provider_V1_Ecosystem: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemRequest: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemResponse: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoRequest: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyResponse: @unchecked Sendable {}
    extension Services_Provider_V1_SearchWalletConfigurationsRequest: @unchecked Sendable {}
    extension Services_Provider_V1_SearchWalletConfigurationResponse: @unchecked Sendable {}
    extension Services_Provider_V1_WalletConfiguration: @unchecked Sendable {}
    extension Services_Provider_V1_WalletExternalIdentity: @unchecked Sendable {}
    extension Services_Provider_V1_IonOptions: @unchecked Sendable {}
    extension Services_Provider_V1_IonOptions.IonNetwork: @unchecked Sendable {}
    extension Services_Provider_V1_IndyOptions: @unchecked Sendable {}
    extension Services_Provider_V1_IndyOptions.IndyNetwork: @unchecked Sendable {}
    extension Services_Provider_V1_UpgradeDidRequest: @unchecked Sendable {}
    extension Services_Provider_V1_UpgradeDidRequest.OneOf_Account: @unchecked Sendable {}
    extension Services_Provider_V1_UpgradeDidRequest.OneOf_Options: @unchecked Sendable {}
    extension Services_Provider_V1_UpgradeDidResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "services.provider.v1"

extension Services_Provider_V1_IdentityProvider: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unknown"),
        1: .same(proto: "Email"),
        2: .same(proto: "Phone"),
        3: .same(proto: "Passkey"),
        4: .same(proto: "TrinsicAuthenticator"),
    ]
}

extension Services_Provider_V1_Ecosystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Ecosystem"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
        3: .same(proto: "description"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &id)
            case 2: try decoder.decodeSingularStringField(value: &name)
            case 3: try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_Ecosystem, rhs: Services_Provider_V1_Ecosystem) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "description"),
        4: .same(proto: "details"),
        5: .same(proto: "domain"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &description_p)
            case 4: try decoder.decodeSingularMessageField(value: &_details)
            case 5: try decoder.decodeSingularStringField(value: &domain)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !domain.isEmpty {
            try visitor.visitSingularStringField(value: domain, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemRequest, rhs: Services_Provider_V1_CreateEcosystemRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._details != rhs._details { return false }
        if lhs.domain != rhs.domain { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
        2: .same(proto: "profile"),
        3: .standard(proto: "confirmation_method"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_ecosystem)
            case 2: try decoder.decodeSingularMessageField(value: &_profile)
            case 3: try decoder.decodeSingularEnumField(value: &confirmationMethod)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._profile {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if confirmationMethod != .none {
            try visitor.visitSingularEnumField(value: confirmationMethod, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemResponse, rhs: Services_Provider_V1_CreateEcosystemResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs._profile != rhs._profile { return false }
        if lhs.confirmationMethod != rhs.confirmationMethod { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoRequest, rhs: Services_Provider_V1_EcosystemInfoRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoResponse, rhs: Services_Provider_V1_EcosystemInfoResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyRequest, rhs: Services_Provider_V1_GetOberonKeyRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyResponse, rhs: Services_Provider_V1_GetOberonKeyResponse) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_SearchWalletConfigurationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SearchWalletConfigurationsRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "query_filter"),
        2: .standard(proto: "continuation_token"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &queryFilter)
            case 2: try decoder.decodeSingularStringField(value: &continuationToken)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !queryFilter.isEmpty {
            try visitor.visitSingularStringField(value: queryFilter, fieldNumber: 1)
        }
        if !continuationToken.isEmpty {
            try visitor.visitSingularStringField(value: continuationToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_SearchWalletConfigurationsRequest, rhs: Services_Provider_V1_SearchWalletConfigurationsRequest) -> Bool {
        if lhs.queryFilter != rhs.queryFilter { return false }
        if lhs.continuationToken != rhs.continuationToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_SearchWalletConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SearchWalletConfigurationResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "results"),
        2: .standard(proto: "has_more_results"),
        4: .standard(proto: "continuation_token"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &results)
            case 2: try decoder.decodeSingularBoolField(value: &hasMoreResults_p)
            case 4: try decoder.decodeSingularStringField(value: &continuationToken)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !results.isEmpty {
            try visitor.visitRepeatedMessageField(value: results, fieldNumber: 1)
        }
        if hasMoreResults_p != false {
            try visitor.visitSingularBoolField(value: hasMoreResults_p, fieldNumber: 2)
        }
        if !continuationToken.isEmpty {
            try visitor.visitSingularStringField(value: continuationToken, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_SearchWalletConfigurationResponse, rhs: Services_Provider_V1_SearchWalletConfigurationResponse) -> Bool {
        if lhs.results != rhs.results { return false }
        if lhs.hasMoreResults_p != rhs.hasMoreResults_p { return false }
        if lhs.continuationToken != rhs.continuationToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_WalletConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WalletConfiguration"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "email"),
        3: .same(proto: "sms"),
        4: .standard(proto: "wallet_id"),
        5: .standard(proto: "public_did"),
        6: .standard(proto: "config_type"),
        7: .standard(proto: "auth_tokens"),
        8: .standard(proto: "external_identity_ids"),
        9: .standard(proto: "ecosystem_id"),
        10: .same(proto: "description"),
        11: .standard(proto: "external_identities"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &email)
            case 3: try decoder.decodeSingularStringField(value: &sms)
            case 4: try decoder.decodeSingularStringField(value: &walletID)
            case 5: try decoder.decodeSingularStringField(value: &publicDid)
            case 6: try decoder.decodeSingularStringField(value: &configType)
            case 7: try decoder.decodeRepeatedMessageField(value: &authTokens)
            case 8: try decoder.decodeRepeatedStringField(value: &externalIdentityIds)
            case 9: try decoder.decodeSingularStringField(value: &ecosystemID)
            case 10: try decoder.decodeSingularStringField(value: &description_p)
            case 11: try decoder.decodeRepeatedMessageField(value: &externalIdentities)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !email.isEmpty {
            try visitor.visitSingularStringField(value: email, fieldNumber: 2)
        }
        if !sms.isEmpty {
            try visitor.visitSingularStringField(value: sms, fieldNumber: 3)
        }
        if !walletID.isEmpty {
            try visitor.visitSingularStringField(value: walletID, fieldNumber: 4)
        }
        if !publicDid.isEmpty {
            try visitor.visitSingularStringField(value: publicDid, fieldNumber: 5)
        }
        if !configType.isEmpty {
            try visitor.visitSingularStringField(value: configType, fieldNumber: 6)
        }
        if !authTokens.isEmpty {
            try visitor.visitRepeatedMessageField(value: authTokens, fieldNumber: 7)
        }
        if !externalIdentityIds.isEmpty {
            try visitor.visitRepeatedStringField(value: externalIdentityIds, fieldNumber: 8)
        }
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 9)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 10)
        }
        if !externalIdentities.isEmpty {
            try visitor.visitRepeatedMessageField(value: externalIdentities, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_WalletConfiguration, rhs: Services_Provider_V1_WalletConfiguration) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.email != rhs.email { return false }
        if lhs.sms != rhs.sms { return false }
        if lhs.walletID != rhs.walletID { return false }
        if lhs.publicDid != rhs.publicDid { return false }
        if lhs.configType != rhs.configType { return false }
        if lhs.authTokens != rhs.authTokens { return false }
        if lhs.externalIdentityIds != rhs.externalIdentityIds { return false }
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.externalIdentities != rhs.externalIdentities { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_WalletExternalIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WalletExternalIdentity"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "provider"),
        2: .same(proto: "id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &provider)
            case 2: try decoder.decodeSingularStringField(value: &id)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if provider != .unknown {
            try visitor.visitSingularEnumField(value: provider, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_WalletExternalIdentity, rhs: Services_Provider_V1_WalletExternalIdentity) -> Bool {
        if lhs.provider != rhs.provider { return false }
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_IonOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".IonOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "network"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &network)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if network != .testNet {
            try visitor.visitSingularEnumField(value: network, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_IonOptions, rhs: Services_Provider_V1_IonOptions) -> Bool {
        if lhs.network != rhs.network { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_IonOptions.IonNetwork: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "TestNet"),
        1: .same(proto: "MainNet"),
    ]
}

extension Services_Provider_V1_IndyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".IndyOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "network"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &network)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if network != .danube {
            try visitor.visitSingularEnumField(value: network, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_IndyOptions, rhs: Services_Provider_V1_IndyOptions) -> Bool {
        if lhs.network != rhs.network { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_IndyOptions.IndyNetwork: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Danube"),
        1: .same(proto: "SovrinBuilder"),
        2: .same(proto: "SovrinStaging"),
        3: .same(proto: "Sovrin"),
        4: .same(proto: "IdUnionTest"),
        5: .same(proto: "IdUnion"),
        6: .same(proto: "IndicioTest"),
        7: .same(proto: "IndicioDemo"),
        8: .same(proto: "Indicio"),
    ]
}

extension Services_Provider_V1_UpgradeDidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpgradeDidRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "email"),
        2: .standard(proto: "wallet_id"),
        6: .standard(proto: "did_uri"),
        3: .same(proto: "method"),
        4: .standard(proto: "ion_options"),
        5: .standard(proto: "indy_options"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .email(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .walletID(v)
                    }
                }()
            case 3: try decoder.decodeSingularEnumField(value: &method)
            case 4: try {
                    var v: Services_Provider_V1_IonOptions?
                    var hadOneofValue = false
                    if let current = self.options {
                        hadOneofValue = true
                        if case let .ionOptions(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.options = .ionOptions(v)
                    }
                }()
            case 5: try {
                    var v: Services_Provider_V1_IndyOptions?
                    var hadOneofValue = false
                    if let current = self.options {
                        hadOneofValue = true
                        if case let .indyOptions(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.options = .indyOptions(v)
                    }
                }()
            case 6: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .didUri(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch account {
        case .email?: try {
                guard case let .email(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .walletID?: try {
                guard case let .walletID(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        default: break
        }
        if method != .key {
            try visitor.visitSingularEnumField(value: method, fieldNumber: 3)
        }
        switch options {
        case .ionOptions?: try {
                guard case let .ionOptions(v)? = self.options else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .indyOptions?: try {
                guard case let .indyOptions(v)? = self.options else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try { if case let .didUri(v)? = self.account {
            try visitor.visitSingularStringField(value: v, fieldNumber: 6)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpgradeDidRequest, rhs: Services_Provider_V1_UpgradeDidRequest) -> Bool {
        if lhs.account != rhs.account { return false }
        if lhs.method != rhs.method { return false }
        if lhs.options != rhs.options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_UpgradeDidResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpgradeDidResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "did"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &did)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !did.isEmpty {
            try visitor.visitSingularStringField(value: did, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpgradeDidResponse, rhs: Services_Provider_V1_UpgradeDidResponse) -> Bool {
        if lhs.did != rhs.did { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

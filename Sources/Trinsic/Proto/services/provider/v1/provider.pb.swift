// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/provider/v1/provider.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum Services_Provider_V1_ParticipantType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case individual // = 0
    case organization // = 1
    case UNRECOGNIZED(Int)

    public init() {
        self = .individual
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .individual
        case 1: self = .organization
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .individual: return 0
        case .organization: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Provider_V1_ParticipantType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [Services_Provider_V1_ParticipantType] = [
            .individual,
            .organization,
        ]
    }

#endif // swift(>=4.2)

public struct Services_Provider_V1_Invite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = .init()

    public var code: String = .init()

    public var created: String = .init()

    public var accepted: String = .init()

    public var expires: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_InviteRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of participant being invited (individual/organization)
    public var participant: Services_Provider_V1_ParticipantType = .individual

    /// Description of invitation
    public var description_p: String = .init()

    /// Account details of invitee
    public var details: Services_Account_V1_AccountDetails {
        get { return _details ?? Services_Account_V1_AccountDetails() }
        set { _details = newValue }
    }

    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool { return _details != nil }
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() { _details = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DidCommInvitation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _details: Services_Account_V1_AccountDetails?
}

public struct Services_Provider_V1_InviteResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of created invitation
    public var invitationID: String = .init()

    /// Invitation Code that must be passed with the account 'SignIn' request
    /// to correlate this user with the invitation sent.
    public var invitationCode: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request details for the status of onboarding
/// an individual or organization.
/// The reference_id passed is the response from the
/// `Onboard` method call
public struct Services_Provider_V1_InvitationStatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of invitation
    public var invitationID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_InvitationStatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of invitation
    public var status: Services_Provider_V1_InvitationStatusResponse.Status = .error

    /// Human-readable string with details about invitation status
    public var statusDetails: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Onboarding resulted in error
        case error // = 0

        /// The participant has been invited
        case invitationSent // = 1

        /// The participant has been onboarded
        case completed // = 2

        /// The invite has expired
        case expired // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .error
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .error
            case 1: self = .invitationSent
            case 2: self = .completed
            case 3: self = .expired
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .error: return 0
            case .invitationSent: return 1
            case .completed: return 2
            case .expired: return 3
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension Services_Provider_V1_InvitationStatusResponse.Status: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [Services_Provider_V1_InvitationStatusResponse.Status] = [
            .error,
            .invitationSent,
            .completed,
            .expired,
        ]
    }

#endif // swift(>=4.2)

public struct Services_Provider_V1_Ecosystem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URN of the ecosystem
    public var id: String = .init()

    /// Globally unique name for the ecosystem
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    /// External URL associated with the organization or ecosystem entity
    public var uri: String = .init()

    /// Configured webhooks, if any
    public var webhooks: [Services_Provider_V1_WebhookConfig] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_WebhookConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of the webhook
    public var id: String = .init()

    /// Destination to post webhook calls to
    public var destinationURL: String = .init()

    /// Events the webhook is subscribed to
    public var events: [String] = []

    /// Whether we are able to sucessfully send events to the webhook
    public var status: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_CreateEcosystemRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Globally unique name for the Ecosystem. This name will be
    /// part of the ecosystem specific URLs and namespaces.
    /// Allowed characters are lowercase letters, numbers, underscore and hyphen.
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    /// External URL associated with your organization or ecosystem entity
    public var uri: String = .init()

    /// The account details of the owner of the ecosystem
    public var details: Services_Account_V1_AccountDetails {
        get { return _details ?? Services_Account_V1_AccountDetails() }
        set { _details = newValue }
    }

    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool { return _details != nil }
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() { _details = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Services_Account_V1_AccountDetails?
}

public struct Services_Provider_V1_CreateEcosystemResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Details of the created ecosystem
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    /// Account profile for auth of the owner of the ecosystem
    public var profile: Services_Account_V1_AccountProfile {
        get { return _profile ?? Services_Account_V1_AccountProfile() }
        set { _profile = newValue }
    }

    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool { return _profile != nil }
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() { _profile = nil }

    /// Indicates if confirmation of account is required.
    /// This setting is configured globally by the server administrator.
    public var confirmationMethod: Services_Account_V1_ConfirmationMethod = .none

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
    fileprivate var _profile: Services_Account_V1_AccountProfile?
}

/// Request to update an ecosystem
public struct Services_Provider_V1_UpdateEcosystemRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the ecosystem to update
    public var ecosystemID: String = .init()

    /// Description of the ecosystem
    public var description_p: String = .init()

    /// External URL associated with the organization or ecosystem entity
    public var uri: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `UpdateEcosystemRequest`
public struct Services_Provider_V1_UpdateEcosystemResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to add a webhook to an ecosystem
public struct Services_Provider_V1_AddWebhookRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of ecosystem to add webhook to
    public var ecosystemID: String = .init()

    /// Destination to post webhook calls to
    public var destinationURL: String = .init()

    /// HMAC secret for webhook validation
    public var secret: String = .init()

    /// Events to subscribe to. Default is "*" (all events)
    public var events: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `AddWebhookRequest`
public struct Services_Provider_V1_AddWebhookResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem with new webhook
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to delete a webhook from an ecosystem
public struct Services_Provider_V1_DeleteWebhookRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of ecosystem from which to delete webhook
    public var ecosystemID: String = .init()

    /// ID of webhook to delete
    public var webhookID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `DeleteWebhookRequest`
public struct Services_Provider_V1_DeleteWebhookResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem after removal of webhook
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to fetch information about an ecosystem
public struct Services_Provider_V1_EcosystemInfoRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of ecosystem to fetch information about
    public var ecosystemID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `InfoRequest`
public struct Services_Provider_V1_EcosystemInfoResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem corresponding to requested `ecosystem_id`
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

public struct Services_Provider_V1_GenerateTokenRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Description to identify this token
    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Services_Provider_V1_GenerateTokenResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Account authentication profile that contains unprotected token
    public var profile: Services_Account_V1_AccountProfile {
        get { return _profile ?? Services_Account_V1_AccountProfile() }
        set { _profile = newValue }
    }

    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool { return _profile != nil }
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() { _profile = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Services_Account_V1_AccountProfile?
}

/// request message for GetOberonKey
public struct Services_Provider_V1_GetOberonKeyRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// response message for GetOberonKey
public struct Services_Provider_V1_GetOberonKeyResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Oberon Public Key as RAW base64 URL encoded string
    public var key: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// generates an events token bound to the provided ed25519 pk
public struct Services_Provider_V1_GetEventTokenRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pk: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// response message containing a token (JWT) that can be used
/// to connect directly to the message streaming architecture
public struct Services_Provider_V1_GetEventTokenResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// a JWT bound to the PK provided in the request
    public var token: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Services_Provider_V1_ParticipantType: @unchecked Sendable {}
    extension Services_Provider_V1_Invite: @unchecked Sendable {}
    extension Services_Provider_V1_InviteRequest: @unchecked Sendable {}
    extension Services_Provider_V1_InviteRequest.DidCommInvitation: @unchecked Sendable {}
    extension Services_Provider_V1_InviteResponse: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusRequest: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusResponse: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusResponse.Status: @unchecked Sendable {}
    extension Services_Provider_V1_Ecosystem: @unchecked Sendable {}
    extension Services_Provider_V1_WebhookConfig: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemRequest: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemResponse: @unchecked Sendable {}
    extension Services_Provider_V1_UpdateEcosystemRequest: @unchecked Sendable {}
    extension Services_Provider_V1_UpdateEcosystemResponse: @unchecked Sendable {}
    extension Services_Provider_V1_AddWebhookRequest: @unchecked Sendable {}
    extension Services_Provider_V1_AddWebhookResponse: @unchecked Sendable {}
    extension Services_Provider_V1_DeleteWebhookRequest: @unchecked Sendable {}
    extension Services_Provider_V1_DeleteWebhookResponse: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoRequest: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GenerateTokenRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GenerateTokenResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetEventTokenRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetEventTokenResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "services.provider.v1"

extension Services_Provider_V1_ParticipantType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "participant_type_individual"),
        1: .same(proto: "participant_type_organization"),
    ]
}

extension Services_Provider_V1_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Invite"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "code"),
        3: .same(proto: "created"),
        4: .same(proto: "accepted"),
        5: .same(proto: "expires"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &code)
            case 3: try try decoder.decodeSingularStringField(value: &created)
            case 4: try try decoder.decodeSingularStringField(value: &accepted)
            case 5: try try decoder.decodeSingularStringField(value: &expires)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !code.isEmpty {
            try visitor.visitSingularStringField(value: code, fieldNumber: 2)
        }
        if !created.isEmpty {
            try visitor.visitSingularStringField(value: created, fieldNumber: 3)
        }
        if !accepted.isEmpty {
            try visitor.visitSingularStringField(value: accepted, fieldNumber: 4)
        }
        if !expires.isEmpty {
            try visitor.visitSingularStringField(value: expires, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_Invite, rhs: Services_Provider_V1_Invite) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.code != rhs.code { return false }
        if lhs.created != rhs.created { return false }
        if lhs.accepted != rhs.accepted { return false }
        if lhs.expires != rhs.expires { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InviteRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "participant"),
        2: .same(proto: "description"),
        3: .same(proto: "details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &participant)
            case 2: try try decoder.decodeSingularStringField(value: &description_p)
            case 3: try try decoder.decodeSingularMessageField(value: &_details)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if participant != .individual {
            try visitor.visitSingularEnumField(value: participant, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteRequest, rhs: Services_Provider_V1_InviteRequest) -> Bool {
        if lhs.participant != rhs.participant { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._details != rhs._details { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InviteRequest.DidCommInvitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = Services_Provider_V1_InviteRequest.protoMessageName + ".DidCommInvitation"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteRequest.DidCommInvitation, rhs: Services_Provider_V1_InviteRequest.DidCommInvitation) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InviteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InviteResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        10: .standard(proto: "invitation_id"),
        11: .standard(proto: "invitation_code"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 10: try try decoder.decodeSingularStringField(value: &invitationID)
            case 11: try try decoder.decodeSingularStringField(value: &invitationCode)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !invitationID.isEmpty {
            try visitor.visitSingularStringField(value: invitationID, fieldNumber: 10)
        }
        if !invitationCode.isEmpty {
            try visitor.visitSingularStringField(value: invitationCode, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteResponse, rhs: Services_Provider_V1_InviteResponse) -> Bool {
        if lhs.invitationID != rhs.invitationID { return false }
        if lhs.invitationCode != rhs.invitationCode { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InvitationStatusRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "invitation_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &invitationID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !invitationID.isEmpty {
            try visitor.visitSingularStringField(value: invitationID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InvitationStatusRequest, rhs: Services_Provider_V1_InvitationStatusRequest) -> Bool {
        if lhs.invitationID != rhs.invitationID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InvitationStatusResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .standard(proto: "status_details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &status)
            case 2: try try decoder.decodeSingularStringField(value: &statusDetails)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .error {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        if !statusDetails.isEmpty {
            try visitor.visitSingularStringField(value: statusDetails, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InvitationStatusResponse, rhs: Services_Provider_V1_InvitationStatusResponse) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.statusDetails != rhs.statusDetails { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusResponse.Status: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Error"),
        1: .same(proto: "InvitationSent"),
        2: .same(proto: "Completed"),
        3: .same(proto: "Expired"),
    ]
}

extension Services_Provider_V1_Ecosystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Ecosystem"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
        3: .same(proto: "description"),
        4: .same(proto: "uri"),
        5: .same(proto: "webhooks"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &name)
            case 3: try try decoder.decodeSingularStringField(value: &description_p)
            case 4: try try decoder.decodeSingularStringField(value: &uri)
            case 5: try try decoder.decodeRepeatedMessageField(value: &webhooks)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 4)
        }
        if !webhooks.isEmpty {
            try visitor.visitRepeatedMessageField(value: webhooks, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_Ecosystem, rhs: Services_Provider_V1_Ecosystem) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs.webhooks != rhs.webhooks { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_WebhookConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WebhookConfig"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "destination_url"),
        4: .same(proto: "events"),
        5: .same(proto: "status"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &destinationURL)
            case 4: try try decoder.decodeRepeatedStringField(value: &events)
            case 5: try try decoder.decodeSingularStringField(value: &status)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !destinationURL.isEmpty {
            try visitor.visitSingularStringField(value: destinationURL, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedStringField(value: events, fieldNumber: 4)
        }
        if !status.isEmpty {
            try visitor.visitSingularStringField(value: status, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_WebhookConfig, rhs: Services_Provider_V1_WebhookConfig) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.destinationURL != rhs.destinationURL { return false }
        if lhs.events != rhs.events { return false }
        if lhs.status != rhs.status { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "description"),
        3: .same(proto: "uri"),
        4: .same(proto: "details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularStringField(value: &description_p)
            case 3: try try decoder.decodeSingularStringField(value: &uri)
            case 4: try try decoder.decodeSingularMessageField(value: &_details)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 3)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemRequest, rhs: Services_Provider_V1_CreateEcosystemRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs._details != rhs._details { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
        2: .same(proto: "profile"),
        3: .standard(proto: "confirmation_method"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            case 2: try try decoder.decodeSingularMessageField(value: &_profile)
            case 3: try try decoder.decodeSingularEnumField(value: &confirmationMethod)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._profile {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if confirmationMethod != .none {
            try visitor.visitSingularEnumField(value: confirmationMethod, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemResponse, rhs: Services_Provider_V1_CreateEcosystemResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs._profile != rhs._profile { return false }
        if lhs.confirmationMethod != rhs.confirmationMethod { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_UpdateEcosystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateEcosystemRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ecosystem_id"),
        2: .same(proto: "description"),
        3: .same(proto: "uri"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ecosystemID)
            case 2: try try decoder.decodeSingularStringField(value: &description_p)
            case 3: try try decoder.decodeSingularStringField(value: &uri)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpdateEcosystemRequest, rhs: Services_Provider_V1_UpdateEcosystemRequest) -> Bool {
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_UpdateEcosystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateEcosystemResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "Ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpdateEcosystemResponse, rhs: Services_Provider_V1_UpdateEcosystemResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_AddWebhookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddWebhookRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ecosystem_id"),
        2: .standard(proto: "destination_url"),
        3: .same(proto: "secret"),
        4: .same(proto: "events"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ecosystemID)
            case 2: try try decoder.decodeSingularStringField(value: &destinationURL)
            case 3: try try decoder.decodeSingularStringField(value: &secret)
            case 4: try try decoder.decodeRepeatedStringField(value: &events)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 1)
        }
        if !destinationURL.isEmpty {
            try visitor.visitSingularStringField(value: destinationURL, fieldNumber: 2)
        }
        if !secret.isEmpty {
            try visitor.visitSingularStringField(value: secret, fieldNumber: 3)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedStringField(value: events, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_AddWebhookRequest, rhs: Services_Provider_V1_AddWebhookRequest) -> Bool {
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.destinationURL != rhs.destinationURL { return false }
        if lhs.secret != rhs.secret { return false }
        if lhs.events != rhs.events { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_AddWebhookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddWebhookResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_AddWebhookResponse, rhs: Services_Provider_V1_AddWebhookResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_DeleteWebhookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteWebhookRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ecosystem_id"),
        2: .standard(proto: "webhook_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ecosystemID)
            case 2: try try decoder.decodeSingularStringField(value: &webhookID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 1)
        }
        if !webhookID.isEmpty {
            try visitor.visitSingularStringField(value: webhookID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_DeleteWebhookRequest, rhs: Services_Provider_V1_DeleteWebhookRequest) -> Bool {
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.webhookID != rhs.webhookID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_DeleteWebhookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteWebhookResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_DeleteWebhookResponse, rhs: Services_Provider_V1_DeleteWebhookResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ecosystem_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ecosystemID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !ecosystemID.isEmpty {
            try visitor.visitSingularStringField(value: ecosystemID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoRequest, rhs: Services_Provider_V1_EcosystemInfoRequest) -> Bool {
        if lhs.ecosystemID != rhs.ecosystemID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoResponse, rhs: Services_Provider_V1_EcosystemInfoResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GenerateTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GenerateTokenRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GenerateTokenRequest, rhs: Services_Provider_V1_GenerateTokenRequest) -> Bool {
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GenerateTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GenerateTokenResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "profile"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_profile)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._profile {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GenerateTokenResponse, rhs: Services_Provider_V1_GenerateTokenResponse) -> Bool {
        if lhs._profile != rhs._profile { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyRequest, rhs: Services_Provider_V1_GetOberonKeyRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &key)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyResponse, rhs: Services_Provider_V1_GetOberonKeyResponse) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetEventTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetEventTokenRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "pk"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &pk)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !pk.isEmpty {
            try visitor.visitSingularBytesField(value: pk, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetEventTokenRequest, rhs: Services_Provider_V1_GetEventTokenRequest) -> Bool {
        if lhs.pk != rhs.pk { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetEventTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetEventTokenResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "token"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &token)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !token.isEmpty {
            try visitor.visitSingularStringField(value: token, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetEventTokenResponse, rhs: Services_Provider_V1_GetEventTokenResponse) -> Bool {
        if lhs.token != rhs.token { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

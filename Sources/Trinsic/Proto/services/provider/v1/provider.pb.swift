// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/provider/v1/provider.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// Type of participant being invited to ecosystem
public enum Services_Provider_V1_ParticipantType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Participant is an individual
    case individual // = 0

    /// Participant is an organization
    case organization // = 1
    case UNRECOGNIZED(Int)

    public init() {
        self = .individual
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .individual
        case 1: self = .organization
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .individual: return 0
        case .organization: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Provider_V1_ParticipantType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [Services_Provider_V1_ParticipantType] = [
            .individual,
            .organization,
        ]
    }

#endif // swift(>=4.2)

/// Request to invite a participant to an ecosystem
public struct Services_Provider_V1_InviteRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of participant being invited (individual/organization)
    public var participant: Services_Provider_V1_ParticipantType = .individual

    /// Description of invitation
    public var description_p: String = .init()

    /// Account details of invitee
    public var details: Services_Account_V1_AccountDetails {
        get { return _details ?? Services_Account_V1_AccountDetails() }
        set { _details = newValue }
    }

    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool { return _details != nil }
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() { _details = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DidCommInvitation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
    }

    public init() {}

    fileprivate var _details: Services_Account_V1_AccountDetails?
}

/// Response to `InviteRequest`
public struct Services_Provider_V1_InviteResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of created invitation
    public var invitationID: String = .init()

    /// Invitation code -- must be passed back in `LoginRequest`
    public var invitationCode: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request details for the status of an invitation
public struct Services_Provider_V1_InvitationStatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of invitation, received from `InviteResponse`
    public var invitationID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `InvitationStatusRequest`
public struct Services_Provider_V1_InvitationStatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of invitation
    public var status: Services_Provider_V1_InvitationStatusResponse.Status = .error

    /// Human-readable string with details about invitation status
    public var statusDetails: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Onboarding resulted in error
        case error // = 0

        /// The participant has been invited
        case invitationSent // = 1

        /// The participant has been onboarded
        case completed // = 2

        /// The invite has expired
        case expired // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .error
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .error
            case 1: self = .invitationSent
            case 2: self = .completed
            case 3: self = .expired
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .error: return 0
            case .invitationSent: return 1
            case .completed: return 2
            case .expired: return 3
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension Services_Provider_V1_InvitationStatusResponse.Status: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [Services_Provider_V1_InvitationStatusResponse.Status] = [
            .error,
            .invitationSent,
            .completed,
            .expired,
        ]
    }

#endif // swift(>=4.2)

/// Details of an ecosystem
public struct Services_Provider_V1_Ecosystem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URN of the ecosystem
    public var id: String = .init()

    /// Globally unique name for the ecosystem
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    /// External URL associated with the organization or ecosystem entity
    public var uri: String = .init()

    /// Configured webhooks, if any
    public var webhooks: [Services_Provider_V1_WebhookConfig] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Webhook configured on an ecosystem
public struct Services_Provider_V1_WebhookConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// UUID of the webhook
    public var id: String = .init()

    /// HTTPS URL to POST webhook calls to
    public var destinationURL: String = .init()

    /// Events the webhook is subscribed to
    public var events: [String] = []

    /// Last known status of webhook (whether or not Trinsic can successfully reach destination)
    public var status: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// A grant authorizing `actions` on a `resourceId`
public struct Services_Provider_V1_Grant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the urn of the resource
    public var resourceID: String = .init()

    /// list of actions that are allowed
    public var actions: [String] = []

    /// any child grants
    public var childGrants: [Services_Provider_V1_Grant] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to create an ecosystem
public struct Services_Provider_V1_CreateEcosystemRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Globally unique name for the Ecosystem. This name will be
    /// part of the ecosystem-specific URLs and namespaces.
    /// Allowed characters are lowercase letters, numbers, underscore and hyphen.
    /// If not passed, ecosystem name will be auto-generated.
    public var name: String = .init()

    /// Ecosystem description
    public var description_p: String = .init()

    /// External URL associated with your organization or ecosystem entity
    public var uri: String = .init()

    /// The account details of the owner of the ecosystem
    public var details: Services_Account_V1_AccountDetails {
        get { return _details ?? Services_Account_V1_AccountDetails() }
        set { _details = newValue }
    }

    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool { return _details != nil }
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() { _details = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Services_Account_V1_AccountDetails?
}

/// Response to `CreateEcosystemRequest`
public struct Services_Provider_V1_CreateEcosystemResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Details of the created ecosystem
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    /// Account profile for auth of the owner of the ecosystem
    public var profile: Services_Account_V1_AccountProfile {
        get { return _profile ?? Services_Account_V1_AccountProfile() }
        set { _profile = newValue }
    }

    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool { return _profile != nil }
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() { _profile = nil }

    /// Indicates if confirmation of account is required.
    public var confirmationMethod: Services_Account_V1_ConfirmationMethod = .none

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
    fileprivate var _profile: Services_Account_V1_AccountProfile?
}

/// Request to update an ecosystem's metadata
public struct Services_Provider_V1_UpdateEcosystemRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// New description of the ecosystem
    public var description_p: String = .init()

    /// New external URL associated with the organization or ecosystem entity
    public var uri: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `UpdateEcosystemRequest`
public struct Services_Provider_V1_UpdateEcosystemResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current ecosystem metadata, post-update
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to add a webhook to an ecosystem
public struct Services_Provider_V1_AddWebhookRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Destination to post webhook calls to.
    /// Must be a reachable HTTPS URL.
    public var destinationURL: String = .init()

    /// Secret string used for HMAC-SHA256 signing of webhook payloads
    /// to verify that a webhook comes from Trinsic
    public var secret: String = .init()

    /// Events to subscribe to. Default is "*" (all events)
    public var events: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `AddWebhookRequest`
public struct Services_Provider_V1_AddWebhookResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem data with new webhook
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to delete a webhook from an ecosystem
public struct Services_Provider_V1_DeleteWebhookRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of webhook to delete
    public var webhookID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `DeleteWebhookRequest`
public struct Services_Provider_V1_DeleteWebhookResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem data after removal of webhook
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to fetch information about an ecosystem
public struct Services_Provider_V1_EcosystemInfoRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `InfoRequest`
public struct Services_Provider_V1_EcosystemInfoResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ecosystem corresponding to requested `ecosystem_id`
    public var ecosystem: Services_Provider_V1_Ecosystem {
        get { return _ecosystem ?? Services_Provider_V1_Ecosystem() }
        set { _ecosystem = newValue }
    }

    /// Returns true if `ecosystem` has been explicitly set.
    public var hasEcosystem: Bool { return _ecosystem != nil }
    /// Clears the value of `ecosystem`. Subsequent reads from it will return its default value.
    public mutating func clearEcosystem() { _ecosystem = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _ecosystem: Services_Provider_V1_Ecosystem?
}

/// Request to generate an authentication token for the current account
public struct Services_Provider_V1_GenerateTokenRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Description to identify this token
    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `GenerateTokenRequest`
public struct Services_Provider_V1_GenerateTokenResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Account authentication profile that contains unprotected token
    public var profile: Services_Account_V1_AccountProfile {
        get { return _profile ?? Services_Account_V1_AccountProfile() }
        set { _profile = newValue }
    }

    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool { return _profile != nil }
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() { _profile = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Services_Account_V1_AccountProfile?
}

/// Request to fetch the Trinsic public key used
/// to verify authentication token validity
public struct Services_Provider_V1_GetOberonKeyRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `GetOberonKeyRequest`
public struct Services_Provider_V1_GetOberonKeyResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Oberon Public Key as RAW base64-url encoded string
    public var key: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Generates an events token bound to the provided ed25519 public key.
public struct Services_Provider_V1_GetEventTokenRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Raw public key to generate event token for
    public var pk: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response message containing a token (JWT) that can be used
/// to connect directly to the message streaming architecture
public struct Services_Provider_V1_GetEventTokenResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// JWT bound to the public key provided in `GetEventTokenRequest`
    public var token: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Grant permissions to a resource or path in the ecosystem
public struct Services_Provider_V1_GrantAuthorizationRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var account: Services_Provider_V1_GrantAuthorizationRequest.OneOf_Account?

    /// Email address of account being granted permission.
    /// Mutually exclusive with `walletId`.
    public var email: String {
        get {
            if case let .email(v)? = account { return v }
            return String()
        }
        set { account = .email(newValue) }
    }

    /// Wallet ID of account being granted permission.
    /// Mutually exclusive with `email`.
    public var walletID: String {
        get {
            if case let .walletID(v)? = account { return v }
            return String()
        }
        set { account = .walletID(newValue) }
    }

    /// Resource string that account is receiving permissions for.
    /// Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. `ecoId` may be omitted.
    public var resource: String = .init()

    /// Action to authorize. Default is "*" (all)
    public var action: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Account: Equatable {
        /// Email address of account being granted permission.
        /// Mutually exclusive with `walletId`.
        case email(String)
        /// Wallet ID of account being granted permission.
        /// Mutually exclusive with `email`.
        case walletID(String)

        #if !swift(>=4.1)
            public static func == (lhs: Services_Provider_V1_GrantAuthorizationRequest.OneOf_Account, rhs: Services_Provider_V1_GrantAuthorizationRequest.OneOf_Account) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.email, .email): return {
                        guard case let .email(l) = lhs, case let .email(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.walletID, .walletID): return {
                        guard case let .walletID(l) = lhs, case let .walletID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

/// Response to `GrantAuthorizationRequest`
public struct Services_Provider_V1_GrantAuthorizationResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Revoke permissions to a resource or path in the ecosystem
public struct Services_Provider_V1_RevokeAuthorizationRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var account: Services_Provider_V1_RevokeAuthorizationRequest.OneOf_Account?

    /// Email address of account having permission revoked.
    /// Mutually exclusive with `walletId`.
    public var email: String {
        get {
            if case let .email(v)? = account { return v }
            return String()
        }
        set { account = .email(newValue) }
    }

    /// Wallet ID of account having permission revoked.
    /// Mutually exclusive with `email`.
    public var walletID: String {
        get {
            if case let .walletID(v)? = account { return v }
            return String()
        }
        set { account = .walletID(newValue) }
    }

    /// Resource string that account is losing permissions for.
    /// Resources are specified as a RESTful path: /{ecoId}/{resource type}/{resource id}. `ecoId` may be omitted.
    public var resource: String = .init()

    /// Action to revoke. Default is "*" (all)
    public var action: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Account: Equatable {
        /// Email address of account having permission revoked.
        /// Mutually exclusive with `walletId`.
        case email(String)
        /// Wallet ID of account having permission revoked.
        /// Mutually exclusive with `email`.
        case walletID(String)

        #if !swift(>=4.1)
            public static func == (lhs: Services_Provider_V1_RevokeAuthorizationRequest.OneOf_Account, rhs: Services_Provider_V1_RevokeAuthorizationRequest.OneOf_Account) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.email, .email): return {
                        guard case let .email(l) = lhs, case let .email(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.walletID, .walletID): return {
                        guard case let .walletID(l) = lhs, case let .walletID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

/// Response to `RevokeAuthorizationRequest`
public struct Services_Provider_V1_RevokeAuthorizationResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Fetch list of grants that the current account has access to
/// in its ecosystem
public struct Services_Provider_V1_GetAuthorizationsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `GetAuthorizationsRequest`
public struct Services_Provider_V1_GetAuthorizationsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Grants attached to account
    public var grants: [Services_Provider_V1_Grant] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Services_Provider_V1_ParticipantType: @unchecked Sendable {}
    extension Services_Provider_V1_InviteRequest: @unchecked Sendable {}
    extension Services_Provider_V1_InviteRequest.DidCommInvitation: @unchecked Sendable {}
    extension Services_Provider_V1_InviteResponse: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusRequest: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusResponse: @unchecked Sendable {}
    extension Services_Provider_V1_InvitationStatusResponse.Status: @unchecked Sendable {}
    extension Services_Provider_V1_Ecosystem: @unchecked Sendable {}
    extension Services_Provider_V1_WebhookConfig: @unchecked Sendable {}
    extension Services_Provider_V1_Grant: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemRequest: @unchecked Sendable {}
    extension Services_Provider_V1_CreateEcosystemResponse: @unchecked Sendable {}
    extension Services_Provider_V1_UpdateEcosystemRequest: @unchecked Sendable {}
    extension Services_Provider_V1_UpdateEcosystemResponse: @unchecked Sendable {}
    extension Services_Provider_V1_AddWebhookRequest: @unchecked Sendable {}
    extension Services_Provider_V1_AddWebhookResponse: @unchecked Sendable {}
    extension Services_Provider_V1_DeleteWebhookRequest: @unchecked Sendable {}
    extension Services_Provider_V1_DeleteWebhookResponse: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoRequest: @unchecked Sendable {}
    extension Services_Provider_V1_EcosystemInfoResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GenerateTokenRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GenerateTokenResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetOberonKeyResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetEventTokenRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetEventTokenResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GrantAuthorizationRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GrantAuthorizationRequest.OneOf_Account: @unchecked Sendable {}
    extension Services_Provider_V1_GrantAuthorizationResponse: @unchecked Sendable {}
    extension Services_Provider_V1_RevokeAuthorizationRequest: @unchecked Sendable {}
    extension Services_Provider_V1_RevokeAuthorizationRequest.OneOf_Account: @unchecked Sendable {}
    extension Services_Provider_V1_RevokeAuthorizationResponse: @unchecked Sendable {}
    extension Services_Provider_V1_GetAuthorizationsRequest: @unchecked Sendable {}
    extension Services_Provider_V1_GetAuthorizationsResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "services.provider.v1"

extension Services_Provider_V1_ParticipantType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "participant_type_individual"),
        1: .same(proto: "participant_type_organization"),
    ]
}

extension Services_Provider_V1_InviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InviteRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "participant"),
        2: .same(proto: "description"),
        3: .same(proto: "details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &participant)
            case 2: try try decoder.decodeSingularStringField(value: &description_p)
            case 3: try try decoder.decodeSingularMessageField(value: &_details)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if participant != .individual {
            try visitor.visitSingularEnumField(value: participant, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteRequest, rhs: Services_Provider_V1_InviteRequest) -> Bool {
        if lhs.participant != rhs.participant { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._details != rhs._details { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InviteRequest.DidCommInvitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = Services_Provider_V1_InviteRequest.protoMessageName + ".DidCommInvitation"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteRequest.DidCommInvitation, rhs: Services_Provider_V1_InviteRequest.DidCommInvitation) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InviteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InviteResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        10: .standard(proto: "invitation_id"),
        11: .standard(proto: "invitation_code"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 10: try try decoder.decodeSingularStringField(value: &invitationID)
            case 11: try try decoder.decodeSingularStringField(value: &invitationCode)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !invitationID.isEmpty {
            try visitor.visitSingularStringField(value: invitationID, fieldNumber: 10)
        }
        if !invitationCode.isEmpty {
            try visitor.visitSingularStringField(value: invitationCode, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InviteResponse, rhs: Services_Provider_V1_InviteResponse) -> Bool {
        if lhs.invitationID != rhs.invitationID { return false }
        if lhs.invitationCode != rhs.invitationCode { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InvitationStatusRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "invitation_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &invitationID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !invitationID.isEmpty {
            try visitor.visitSingularStringField(value: invitationID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InvitationStatusRequest, rhs: Services_Provider_V1_InvitationStatusRequest) -> Bool {
        if lhs.invitationID != rhs.invitationID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InvitationStatusResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .standard(proto: "status_details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &status)
            case 2: try try decoder.decodeSingularStringField(value: &statusDetails)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .error {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        if !statusDetails.isEmpty {
            try visitor.visitSingularStringField(value: statusDetails, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_InvitationStatusResponse, rhs: Services_Provider_V1_InvitationStatusResponse) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.statusDetails != rhs.statusDetails { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_InvitationStatusResponse.Status: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Error"),
        1: .same(proto: "InvitationSent"),
        2: .same(proto: "Completed"),
        3: .same(proto: "Expired"),
    ]
}

extension Services_Provider_V1_Ecosystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Ecosystem"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
        3: .same(proto: "description"),
        4: .same(proto: "uri"),
        5: .same(proto: "webhooks"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &name)
            case 3: try try decoder.decodeSingularStringField(value: &description_p)
            case 4: try try decoder.decodeSingularStringField(value: &uri)
            case 5: try try decoder.decodeRepeatedMessageField(value: &webhooks)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 4)
        }
        if !webhooks.isEmpty {
            try visitor.visitRepeatedMessageField(value: webhooks, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_Ecosystem, rhs: Services_Provider_V1_Ecosystem) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs.webhooks != rhs.webhooks { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_WebhookConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WebhookConfig"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "destination_url"),
        4: .same(proto: "events"),
        5: .same(proto: "status"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &destinationURL)
            case 4: try try decoder.decodeRepeatedStringField(value: &events)
            case 5: try try decoder.decodeSingularStringField(value: &status)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !destinationURL.isEmpty {
            try visitor.visitSingularStringField(value: destinationURL, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedStringField(value: events, fieldNumber: 4)
        }
        if !status.isEmpty {
            try visitor.visitSingularStringField(value: status, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_WebhookConfig, rhs: Services_Provider_V1_WebhookConfig) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.destinationURL != rhs.destinationURL { return false }
        if lhs.events != rhs.events { return false }
        if lhs.status != rhs.status { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_Grant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Grant"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "resourceId"),
        2: .same(proto: "actions"),
        3: .standard(proto: "child_grants"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &resourceID)
            case 2: try try decoder.decodeRepeatedStringField(value: &actions)
            case 3: try try decoder.decodeRepeatedMessageField(value: &childGrants)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !resourceID.isEmpty {
            try visitor.visitSingularStringField(value: resourceID, fieldNumber: 1)
        }
        if !actions.isEmpty {
            try visitor.visitRepeatedStringField(value: actions, fieldNumber: 2)
        }
        if !childGrants.isEmpty {
            try visitor.visitRepeatedMessageField(value: childGrants, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_Grant, rhs: Services_Provider_V1_Grant) -> Bool {
        if lhs.resourceID != rhs.resourceID { return false }
        if lhs.actions != rhs.actions { return false }
        if lhs.childGrants != rhs.childGrants { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "description"),
        3: .same(proto: "uri"),
        4: .same(proto: "details"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularStringField(value: &description_p)
            case 3: try try decoder.decodeSingularStringField(value: &uri)
            case 4: try try decoder.decodeSingularMessageField(value: &_details)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 3)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemRequest, rhs: Services_Provider_V1_CreateEcosystemRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs._details != rhs._details { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_CreateEcosystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateEcosystemResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
        2: .same(proto: "profile"),
        3: .standard(proto: "confirmation_method"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            case 2: try try decoder.decodeSingularMessageField(value: &_profile)
            case 3: try try decoder.decodeSingularEnumField(value: &confirmationMethod)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._profile {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if confirmationMethod != .none {
            try visitor.visitSingularEnumField(value: confirmationMethod, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_CreateEcosystemResponse, rhs: Services_Provider_V1_CreateEcosystemResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs._profile != rhs._profile { return false }
        if lhs.confirmationMethod != rhs.confirmationMethod { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_UpdateEcosystemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateEcosystemRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
        2: .same(proto: "uri"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &description_p)
            case 2: try try decoder.decodeSingularStringField(value: &uri)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 1)
        }
        if !uri.isEmpty {
            try visitor.visitSingularStringField(value: uri, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpdateEcosystemRequest, rhs: Services_Provider_V1_UpdateEcosystemRequest) -> Bool {
        if lhs.description_p != rhs.description_p { return false }
        if lhs.uri != rhs.uri { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_UpdateEcosystemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateEcosystemResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "Ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_UpdateEcosystemResponse, rhs: Services_Provider_V1_UpdateEcosystemResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_AddWebhookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddWebhookRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "destination_url"),
        2: .same(proto: "secret"),
        3: .same(proto: "events"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &destinationURL)
            case 2: try try decoder.decodeSingularStringField(value: &secret)
            case 3: try try decoder.decodeRepeatedStringField(value: &events)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !destinationURL.isEmpty {
            try visitor.visitSingularStringField(value: destinationURL, fieldNumber: 1)
        }
        if !secret.isEmpty {
            try visitor.visitSingularStringField(value: secret, fieldNumber: 2)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedStringField(value: events, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_AddWebhookRequest, rhs: Services_Provider_V1_AddWebhookRequest) -> Bool {
        if lhs.destinationURL != rhs.destinationURL { return false }
        if lhs.secret != rhs.secret { return false }
        if lhs.events != rhs.events { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_AddWebhookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddWebhookResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_AddWebhookResponse, rhs: Services_Provider_V1_AddWebhookResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_DeleteWebhookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteWebhookRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "webhook_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &webhookID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !webhookID.isEmpty {
            try visitor.visitSingularStringField(value: webhookID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_DeleteWebhookRequest, rhs: Services_Provider_V1_DeleteWebhookRequest) -> Bool {
        if lhs.webhookID != rhs.webhookID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_DeleteWebhookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteWebhookResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_DeleteWebhookResponse, rhs: Services_Provider_V1_DeleteWebhookResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoRequest, rhs: Services_Provider_V1_EcosystemInfoRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_EcosystemInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EcosystemInfoResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ecosystem"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_ecosystem)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._ecosystem {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_EcosystemInfoResponse, rhs: Services_Provider_V1_EcosystemInfoResponse) -> Bool {
        if lhs._ecosystem != rhs._ecosystem { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GenerateTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GenerateTokenRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GenerateTokenRequest, rhs: Services_Provider_V1_GenerateTokenRequest) -> Bool {
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GenerateTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GenerateTokenResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "profile"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_profile)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._profile {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GenerateTokenResponse, rhs: Services_Provider_V1_GenerateTokenResponse) -> Bool {
        if lhs._profile != rhs._profile { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyRequest, rhs: Services_Provider_V1_GetOberonKeyRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetOberonKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetOberonKeyResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &key)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetOberonKeyResponse, rhs: Services_Provider_V1_GetOberonKeyResponse) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetEventTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetEventTokenRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "pk"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &pk)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !pk.isEmpty {
            try visitor.visitSingularBytesField(value: pk, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetEventTokenRequest, rhs: Services_Provider_V1_GetEventTokenRequest) -> Bool {
        if lhs.pk != rhs.pk { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetEventTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetEventTokenResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "token"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &token)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !token.isEmpty {
            try visitor.visitSingularStringField(value: token, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetEventTokenResponse, rhs: Services_Provider_V1_GetEventTokenResponse) -> Bool {
        if lhs.token != rhs.token { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GrantAuthorizationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GrantAuthorizationRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "email"),
        2: .same(proto: "walletId"),
        3: .same(proto: "resource"),
        4: .same(proto: "action"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .email(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .walletID(v)
                    }
                }()
            case 3: try try decoder.decodeSingularStringField(value: &resource)
            case 4: try try decoder.decodeSingularStringField(value: &action)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch account {
        case .email?: try {
                guard case let .email(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .walletID?: try {
                guard case let .walletID(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if !resource.isEmpty {
            try visitor.visitSingularStringField(value: resource, fieldNumber: 3)
        }
        if !action.isEmpty {
            try visitor.visitSingularStringField(value: action, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GrantAuthorizationRequest, rhs: Services_Provider_V1_GrantAuthorizationRequest) -> Bool {
        if lhs.account != rhs.account { return false }
        if lhs.resource != rhs.resource { return false }
        if lhs.action != rhs.action { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GrantAuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GrantAuthorizationResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GrantAuthorizationResponse, rhs: Services_Provider_V1_GrantAuthorizationResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_RevokeAuthorizationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RevokeAuthorizationRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "email"),
        2: .same(proto: "walletId"),
        3: .same(proto: "resource"),
        4: .same(proto: "action"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .email(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.account != nil { try decoder.handleConflictingOneOf() }
                        self.account = .walletID(v)
                    }
                }()
            case 3: try try decoder.decodeSingularStringField(value: &resource)
            case 4: try try decoder.decodeSingularStringField(value: &action)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch account {
        case .email?: try {
                guard case let .email(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .walletID?: try {
                guard case let .walletID(v)? = self.account else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        if !resource.isEmpty {
            try visitor.visitSingularStringField(value: resource, fieldNumber: 3)
        }
        if !action.isEmpty {
            try visitor.visitSingularStringField(value: action, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_RevokeAuthorizationRequest, rhs: Services_Provider_V1_RevokeAuthorizationRequest) -> Bool {
        if lhs.account != rhs.account { return false }
        if lhs.resource != rhs.resource { return false }
        if lhs.action != rhs.action { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_RevokeAuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RevokeAuthorizationResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_RevokeAuthorizationResponse, rhs: Services_Provider_V1_RevokeAuthorizationResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetAuthorizationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetAuthorizationsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetAuthorizationsRequest, rhs: Services_Provider_V1_GetAuthorizationsRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Provider_V1_GetAuthorizationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetAuthorizationsResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "grants"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &grants)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !grants.isEmpty {
            try visitor.visitRepeatedMessageField(value: grants, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Provider_V1_GetAuthorizationsResponse, rhs: Services_Provider_V1_GetAuthorizationsResponse) -> Bool {
        if lhs.grants != rhs.grants { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

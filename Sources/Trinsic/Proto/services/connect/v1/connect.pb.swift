// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/connect/v1/connect.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// The type of verification to perform
public enum Services_Connect_V1_VerificationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Government-issued ID (driver's license, passport, etc)
    case governmentID // = 0
    case UNRECOGNIZED(Int)

    public init() {
        self = .governmentID
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .governmentID
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .governmentID: return 0
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_VerificationType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_VerificationType] = [
            .governmentID,
        ]
    }

#endif // swift(>=4.2)

/// The states a VerificationSession can be in
public enum Services_Connect_V1_IDVSessionState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Session has been created, but not yet shown to user
    case idvCreated // = 0

    /// Session has been shown to user (iframe / popup opened), but
    /// user has not yet logged in.
    case idvInitiated // = 1

    /// User has entered their phone number, but not yet authenticated with the code sent via SMS
    case idvAuthenticating // = 2

    /// User has been authenticated and is performing identity verification
    case idvInProgress // = 3

    /// Session was completed successfully and IDV data is available to RP
    case idvSuccess // = 4

    /// The session failed; reason is present in `fail_code`.
    case idvFailed // = 5
    case UNRECOGNIZED(Int)

    public init() {
        self = .idvCreated
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .idvCreated
        case 1: self = .idvInitiated
        case 2: self = .idvAuthenticating
        case 3: self = .idvInProgress
        case 4: self = .idvSuccess
        case 5: self = .idvFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .idvCreated: return 0
        case .idvInitiated: return 1
        case .idvAuthenticating: return 2
        case .idvInProgress: return 3
        case .idvSuccess: return 4
        case .idvFailed: return 5
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_IDVSessionState: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_IDVSessionState] = [
            .idvCreated,
            .idvInitiated,
            .idvAuthenticating,
            .idvInProgress,
            .idvSuccess,
            .idvFailed,
        ]
    }

#endif // swift(>=4.2)

/// The states an individual Verification can be in
public enum Services_Connect_V1_VerificationState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// This verification has not yet been performed in the flow
    case verificationPending // = 0

    /// This verification has been started by the user, and can be reused from a previous verification, but the user
    /// has not yet decided whether to reuse it.
    case verificationPendingReuse // = 1

    /// This verification has been started by the user, but not yet completed
    case verificationStarted // = 2

    /// This verification has been successfully completed
    case verificationSuccess // = 3

    /// This verification has failed
    case verificationFailed // = 4
    case UNRECOGNIZED(Int)

    public init() {
        self = .verificationPending
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .verificationPending
        case 1: self = .verificationPendingReuse
        case 2: self = .verificationStarted
        case 3: self = .verificationSuccess
        case 4: self = .verificationFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .verificationPending: return 0
        case .verificationPendingReuse: return 1
        case .verificationStarted: return 2
        case .verificationSuccess: return 3
        case .verificationFailed: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_VerificationState: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_VerificationState] = [
            .verificationPending,
            .verificationPendingReuse,
            .verificationStarted,
            .verificationSuccess,
            .verificationFailed,
        ]
    }

#endif // swift(>=4.2)

/// The specific reason an IDVSession is in the `Failed` state
public enum Services_Connect_V1_SessionFailCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The Session is not in a failure state.
    case sessionFailNone // = 0

    /// An internal Trinsic error caused this session to fail
    case sessionFailInternal // = 1

    /// The session failed because one or more of the verifications failed.
    /// The reason for the failure is present in the `fail_reason` field of the relevant `Verification` object(s).
    case sessionFailVerificationFailed // = 2

    /// The session failed because the user failed to authenticate with their phone number too many times.
    case sessionFailAuthentication // = 3

    /// The session expired
    case sessionFailExpired // = 4

    /// The user canceled / rejected the session
    case sessionFailUserCanceled // = 5

    /// The RP canceled the session
    case sessionFailRpCanceled // = 6
    case UNRECOGNIZED(Int)

    public init() {
        self = .sessionFailNone
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sessionFailNone
        case 1: self = .sessionFailInternal
        case 2: self = .sessionFailVerificationFailed
        case 3: self = .sessionFailAuthentication
        case 4: self = .sessionFailExpired
        case 5: self = .sessionFailUserCanceled
        case 6: self = .sessionFailRpCanceled
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .sessionFailNone: return 0
        case .sessionFailInternal: return 1
        case .sessionFailVerificationFailed: return 2
        case .sessionFailAuthentication: return 3
        case .sessionFailExpired: return 4
        case .sessionFailUserCanceled: return 5
        case .sessionFailRpCanceled: return 6
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_SessionFailCode: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_SessionFailCode] = [
            .sessionFailNone,
            .sessionFailInternal,
            .sessionFailVerificationFailed,
            .sessionFailAuthentication,
            .sessionFailExpired,
            .sessionFailUserCanceled,
            .sessionFailRpCanceled,
        ]
    }

#endif // swift(>=4.2)

/// The specific reason a Verification is in the `Failed` state
public enum Services_Connect_V1_VerificationFailCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The verification is not in a failure state
    case verificationFailNone // = 0

    /// An internal Trinsic error caused this verification to fail
    case verificationFailInternal // = 1

    /// The image(s) provided for this verification were either too low-quality, not of the correct type, or otherwise
    /// unable to be processed.
    /// This failure reason is non-terminal; the user is able to retry the verification.
    case verificationFailInvalidImage // = 2

    /// The identity data/images provided are suspected to be inauthentic, fraudulent, or forged.
    case verificationFailInauthentic // = 3

    /// The document provided is either of an unsupported type, or from an unsupported country.
    case verificationFailUnsupportedDocument // = 4
    case UNRECOGNIZED(Int)

    public init() {
        self = .verificationFailNone
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .verificationFailNone
        case 1: self = .verificationFailInternal
        case 2: self = .verificationFailInvalidImage
        case 3: self = .verificationFailInauthentic
        case 4: self = .verificationFailUnsupportedDocument
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .verificationFailNone: return 0
        case .verificationFailInternal: return 1
        case .verificationFailInvalidImage: return 2
        case .verificationFailInauthentic: return 3
        case .verificationFailUnsupportedDocument: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_VerificationFailCode: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_VerificationFailCode] = [
            .verificationFailNone,
            .verificationFailInternal,
            .verificationFailInvalidImage,
            .verificationFailInauthentic,
            .verificationFailUnsupportedDocument,
        ]
    }

#endif // swift(>=4.2)

/// Controls how sessions are ordered in `ListSessions`
public enum Services_Connect_V1_SessionOrdering: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Order sessions according to when they were created
    case created // = 0

    /// Order sessions according to when they last changed state
    case updated // = 1

    /// Order sessions according to their numerical state
    case state // = 2
    case UNRECOGNIZED(Int)

    public init() {
        self = .created
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .created
        case 1: self = .updated
        case 2: self = .state
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .created: return 0
        case .updated: return 1
        case .state: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Services_Connect_V1_SessionOrdering: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Services_Connect_V1_SessionOrdering] = [
            .created,
            .updated,
            .state,
        ]
    }

#endif // swift(>=4.2)

/// An Identity Verification Session
public struct Services_Connect_V1_IDVSession {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the IDVSession.
    public var id: String = .init()

    /// The Client Token for this IDVSession. This should be passed to your frontend to initiate
    /// the IDV flow using Trinsic's Web SDK.
    public var clientToken: String = .init()

    /// State of the IDVSession
    public var state: Services_Connect_V1_IDVSessionState = .idvCreated

    /// The actual Verifications to perform in this IDV flow
    public var verifications: [String: Services_Connect_V1_Verification] = [:]

    /// The reason for the IDVSession's failure.
    /// Only set if `state` is `IDV_FAILED`.
    public var failCode: Services_Connect_V1_SessionFailCode {
        get { _failCode ?? .sessionFailNone }
        set { _failCode = newValue }
    }

    /// Returns true if `failCode` has been explicitly set.
    public var hasFailCode: Bool { _failCode != nil }
    /// Clears the value of `failCode`. Subsequent reads from it will return its default value.
    public mutating func clearFailCode() { _failCode = nil }

    /// The resultant signed VP combining the results of all verifications
    public var resultVp: String {
        get { _resultVp ?? String() }
        set { _resultVp = newValue }
    }

    /// Returns true if `resultVp` has been explicitly set.
    public var hasResultVp: Bool { _resultVp != nil }
    /// Clears the value of `resultVp`. Subsequent reads from it will return its default value.
    public mutating func clearResultVp() { _resultVp = nil }

    /// The unix timestamp, in seconds, that this IDVSession was created
    public var created: UInt64 = 0

    /// The unix timestamp, in seconds, that this IDVSession's `state` was last updated
    public var updated: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _failCode: Services_Connect_V1_SessionFailCode?
    fileprivate var _resultVp: String?
}

/// A Verification that is part of an IDVSession
public struct Services_Connect_V1_Verification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the verification
    public var id: String {
        get { _storage._id }
        set { _uniqueStorage()._id = newValue }
    }

    /// The type of verification (driver's license, passport, proof of address, etc)
    public var type: Services_Connect_V1_VerificationType {
        get { _storage._type }
        set { _uniqueStorage()._type = newValue }
    }

    /// The state of the verification
    public var state: Services_Connect_V1_VerificationState {
        get { _storage._state }
        set { _uniqueStorage()._state = newValue }
    }

    /// The reason for the Verification's failure.
    /// Only set if `state` is `VERIFICATION_FAILED`.
    public var failCode: Services_Connect_V1_VerificationFailCode {
        get { _storage._failCode ?? .verificationFailNone }
        set { _uniqueStorage()._failCode = newValue }
    }

    /// Returns true if `failCode` has been explicitly set.
    public var hasFailCode: Bool { _storage._failCode != nil }
    /// Clears the value of `failCode`. Subsequent reads from it will return its default value.
    public mutating func clearFailCode() { _uniqueStorage()._failCode = nil }

    /// Whether this was a reused (true) or fresh (false) verification.
    /// If `state` is not `VERIFICATION_SUCCESS`, this field is `false` and does not convey useful information.
    public var reused: Bool {
        get { _storage._reused }
        set { _uniqueStorage()._reused = newValue }
    }

    /// The unix timestamp, in seconds, when this verification was begun
    /// by the user -- or `0` if not yet begun.
    public var begun: UInt64 {
        get { _storage._begun }
        set { _uniqueStorage()._begun = newValue }
    }

    /// The unix timestamp, in seconds, when this verification last changed state -- or `0` if it has not yet
    /// begun.
    public var updated: UInt64 {
        get { _storage._updated }
        set { _uniqueStorage()._updated = newValue }
    }

    /// The Government ID options for this Verification.
    /// Only set if this Verification is of type `GOVERNMENT_ID`.
    public var governmentIDOptions: Services_Connect_V1_GovernmentIDOptions {
        get { _storage._governmentIDOptions ?? Services_Connect_V1_GovernmentIDOptions() }
        set { _uniqueStorage()._governmentIDOptions = newValue }
    }

    /// Returns true if `governmentIDOptions` has been explicitly set.
    public var hasGovernmentIDOptions: Bool { _storage._governmentIDOptions != nil }
    /// Clears the value of `governmentIDOptions`. Subsequent reads from it will return its default value.
    public mutating func clearGovernmentIDOptions() { _uniqueStorage()._governmentIDOptions = nil }

    /// Normalized output for manual parsing and usage for this verification
    /// Only set if this Verification is of type `GOVERNMENT_ID` and has succeeded.
    public var normalizedGovernmentIDData: Services_Connect_V1_NormalizedGovernmentIdData {
        get { _storage._normalizedGovernmentIDData ?? Services_Connect_V1_NormalizedGovernmentIdData() }
        set { _uniqueStorage()._normalizedGovernmentIDData = newValue }
    }

    /// Returns true if `normalizedGovernmentIDData` has been explicitly set.
    public var hasNormalizedGovernmentIDData: Bool { _storage._normalizedGovernmentIDData != nil }
    /// Clears the value of `normalizedGovernmentIDData`. Subsequent reads from it will return its default value.
    public mutating func clearNormalizedGovernmentIDData() { _uniqueStorage()._normalizedGovernmentIDData = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _storage = _StorageClass.defaultInstance
}

public struct Services_Connect_V1_NormalizedGovernmentIdData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID number of the underlying identity document
    public var idNumber: String {
        get { _idNumber ?? String() }
        set { _idNumber = newValue }
    }

    /// Returns true if `idNumber` has been explicitly set.
    public var hasIDNumber: Bool { _idNumber != nil }
    /// Clears the value of `idNumber`. Subsequent reads from it will return its default value.
    public mutating func clearIDNumber() { _idNumber = nil }

    /// Given ("first") name of the document holder
    public var givenName: String {
        get { _givenName ?? String() }
        set { _givenName = newValue }
    }

    /// Returns true if `givenName` has been explicitly set.
    public var hasGivenName: Bool { _givenName != nil }
    /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
    public mutating func clearGivenName() { _givenName = nil }

    /// Family ("last") name of the document holder
    public var familyName: String {
        get { _familyName ?? String() }
        set { _familyName = newValue }
    }

    /// Returns true if `familyName` has been explicitly set.
    public var hasFamilyName: Bool { _familyName != nil }
    /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
    public mutating func clearFamilyName() { _familyName = nil }

    /// Full address of the document holder
    public var address: String {
        get { _address ?? String() }
        set { _address = newValue }
    }

    /// Returns true if `address` has been explicitly set.
    public var hasAddress: Bool { _address != nil }
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    public mutating func clearAddress() { _address = nil }

    /// Date of birth of the document holder
    public var dateOfBirth: String {
        get { _dateOfBirth ?? String() }
        set { _dateOfBirth = newValue }
    }

    /// Returns true if `dateOfBirth` has been explicitly set.
    public var hasDateOfBirth: Bool { _dateOfBirth != nil }
    /// Clears the value of `dateOfBirth`. Subsequent reads from it will return its default value.
    public mutating func clearDateOfBirth() { _dateOfBirth = nil }

    /// ISO3 country code of the document
    public var country: String {
        get { _country ?? String() }
        set { _country = newValue }
    }

    /// Returns true if `country` has been explicitly set.
    public var hasCountry: Bool { _country != nil }
    /// Clears the value of `country`. Subsequent reads from it will return its default value.
    public mutating func clearCountry() { _country = nil }

    /// Issuance date of the document
    public var issueDate: String {
        get { _issueDate ?? String() }
        set { _issueDate = newValue }
    }

    /// Returns true if `issueDate` has been explicitly set.
    public var hasIssueDate: Bool { _issueDate != nil }
    /// Clears the value of `issueDate`. Subsequent reads from it will return its default value.
    public mutating func clearIssueDate() { _issueDate = nil }

    /// Expiration date date of the document
    public var expirationDate: String {
        get { _expirationDate ?? String() }
        set { _expirationDate = newValue }
    }

    /// Returns true if `expirationDate` has been explicitly set.
    public var hasExpirationDate: Bool { _expirationDate != nil }
    /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationDate() { _expirationDate = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _idNumber: String?
    fileprivate var _givenName: String?
    fileprivate var _familyName: String?
    fileprivate var _address: String?
    fileprivate var _dateOfBirth: String?
    fileprivate var _country: String?
    fileprivate var _issueDate: String?
    fileprivate var _expirationDate: String?
}

/// Request to create an Identity Verification Session
public struct Services_Connect_V1_CreateSessionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Array of verifications to perform
    public var verifications: [Services_Connect_V1_RequestedVerification] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// A verification to perform in an IDV flow
public struct Services_Connect_V1_RequestedVerification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of verification to perform
    public var type: Services_Connect_V1_VerificationType = .governmentID

    public var options: Services_Connect_V1_RequestedVerification.OneOf_Options?

    /// Options for a Verification of type `GOVERNMENT_ID`
    public var governmentIDOptions: Services_Connect_V1_GovernmentIDOptions {
        get {
            if case let .governmentIDOptions(v)? = options { return v }
            return Services_Connect_V1_GovernmentIDOptions()
        }
        set { options = .governmentIDOptions(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Options: Equatable {
        /// Options for a Verification of type `GOVERNMENT_ID`
        case governmentIDOptions(Services_Connect_V1_GovernmentIDOptions)

        #if !swift(>=4.1)
            public static func == (lhs: Services_Connect_V1_RequestedVerification.OneOf_Options, rhs: Services_Connect_V1_RequestedVerification.OneOf_Options) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.governmentIDOptions, .governmentIDOptions): return {
                        guard case let .governmentIDOptions(l) = lhs, case let .governmentIDOptions(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                }
            }
        #endif
    }

    public init() {}
}

/// Options for a Verification of type `GOVERNMENT_ID`
public struct Services_Connect_V1_GovernmentIDOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fields to retrieve from the Government ID.
    /// If this object is not set, all fields will be retrieved.
    public var fields: Services_Connect_V1_GovernmentIDFields {
        get { _fields ?? Services_Connect_V1_GovernmentIDFields() }
        set { _fields = newValue }
    }

    /// Returns true if `fields` has been explicitly set.
    public var hasFields: Bool { _fields != nil }
    /// Clears the value of `fields`. Subsequent reads from it will return its default value.
    public mutating func clearFields() { _fields = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _fields: Services_Connect_V1_GovernmentIDFields?
}

/// Selection of fields to retrieve from a Government ID. All fields default to `false` unless explicitly set to `true`.
public struct Services_Connect_V1_GovernmentIDFields {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID number of the underlying identity document
    public var idNumber: Bool = false

    /// Given ("first") name of the document holder
    public var givenName: Bool = false

    /// Family ("last") name of the document holder
    public var familyName: Bool = false

    /// Full address of the document holder
    public var address: Bool = false

    /// Date of birth of the document holder
    public var dateOfBirth: Bool = false

    /// ISO3 country code of the document
    public var country: Bool = false

    /// Issuance date of the document
    public var issueDate: Bool = false

    /// Expiration date date of the document
    public var expirationDate: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `CreateIDVSessionRequest`
public struct Services_Connect_V1_CreateSessionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The created IDVSession
    public var session: Services_Connect_V1_IDVSession {
        get { _session ?? Services_Connect_V1_IDVSession() }
        set { _session = newValue }
    }

    /// Returns true if `session` has been explicitly set.
    public var hasSession: Bool { _session != nil }
    /// Clears the value of `session`. Subsequent reads from it will return its default value.
    public mutating func clearSession() { _session = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _session: Services_Connect_V1_IDVSession?
}

/// Request to cancel an Identity Verification Session
public struct Services_Connect_V1_CancelSessionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the IDVSession to cancel
    public var idvSessionID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `CancelIDVSessionRequest`
public struct Services_Connect_V1_CancelSessionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The IDVSession in its current state after cancellation
    public var session: Services_Connect_V1_IDVSession {
        get { _session ?? Services_Connect_V1_IDVSession() }
        set { _session = newValue }
    }

    /// Returns true if `session` has been explicitly set.
    public var hasSession: Bool { _session != nil }
    /// Clears the value of `session`. Subsequent reads from it will return its default value.
    public mutating func clearSession() { _session = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _session: Services_Connect_V1_IDVSession?
}

/// Request to get an IDVSession
public struct Services_Connect_V1_GetSessionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the IDVSession to get
    public var idvSessionID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response to `GetIDVSessionRequest`
public struct Services_Connect_V1_GetSessionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The IDVSession
    public var session: Services_Connect_V1_IDVSession {
        get { _session ?? Services_Connect_V1_IDVSession() }
        set { _session = newValue }
    }

    /// Returns true if `session` has been explicitly set.
    public var hasSession: Bool { _session != nil }
    /// Clears the value of `session`. Subsequent reads from it will return its default value.
    public mutating func clearSession() { _session = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _session: Services_Connect_V1_IDVSession?
}

/// Request to list all IDVSessions you've created
public struct Services_Connect_V1_ListSessionsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field by which sessions should be sorted. Defaults to `CREATED`.
    public var orderBy: Services_Connect_V1_SessionOrdering = .created

    /// The order in which sessions should be sorted. Defaults to `ASCENDING`.
    public var orderDirection: Services_Common_V1_OrderDirection = .ascending

    /// The number of results to return per page.
    /// Must be between `1` and `10`, inclusive.
    /// Defaults to `10`.
    public var pageSize: Int32 {
        get { _pageSize ?? 0 }
        set { _pageSize = newValue }
    }

    /// Returns true if `pageSize` has been explicitly set.
    public var hasPageSize: Bool { _pageSize != nil }
    /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
    public mutating func clearPageSize() { _pageSize = nil }

    /// The page index of results to return.
    /// Starts at `1`.
    /// Defaults to `1`.
    public var page: Int32 {
        get { _page ?? 0 }
        set { _page = newValue }
    }

    /// Returns true if `page` has been explicitly set.
    public var hasPage: Bool { _page != nil }
    /// Clears the value of `page`. Subsequent reads from it will return its default value.
    public mutating func clearPage() { _page = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _pageSize: Int32?
    private var _page: Int32?
}

/// Response to `ListIDVSessionsRequest`
public struct Services_Connect_V1_ListSessionsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The sessions you've created
    public var sessions: [Services_Connect_V1_IDVSession] = []

    /// The total number of sessions you've created
    public var total: Int32 = 0

    /// If `true`, this is not the last page of results.
    /// If `false`, this is the last page of results.
    public var more: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Services_Connect_V1_VerificationType: @unchecked Sendable {}
    extension Services_Connect_V1_IDVSessionState: @unchecked Sendable {}
    extension Services_Connect_V1_VerificationState: @unchecked Sendable {}
    extension Services_Connect_V1_SessionFailCode: @unchecked Sendable {}
    extension Services_Connect_V1_VerificationFailCode: @unchecked Sendable {}
    extension Services_Connect_V1_SessionOrdering: @unchecked Sendable {}
    extension Services_Connect_V1_IDVSession: @unchecked Sendable {}
    extension Services_Connect_V1_Verification: @unchecked Sendable {}
    extension Services_Connect_V1_NormalizedGovernmentIdData: @unchecked Sendable {}
    extension Services_Connect_V1_CreateSessionRequest: @unchecked Sendable {}
    extension Services_Connect_V1_RequestedVerification: @unchecked Sendable {}
    extension Services_Connect_V1_RequestedVerification.OneOf_Options: @unchecked Sendable {}
    extension Services_Connect_V1_GovernmentIDOptions: @unchecked Sendable {}
    extension Services_Connect_V1_GovernmentIDFields: @unchecked Sendable {}
    extension Services_Connect_V1_CreateSessionResponse: @unchecked Sendable {}
    extension Services_Connect_V1_CancelSessionRequest: @unchecked Sendable {}
    extension Services_Connect_V1_CancelSessionResponse: @unchecked Sendable {}
    extension Services_Connect_V1_GetSessionRequest: @unchecked Sendable {}
    extension Services_Connect_V1_GetSessionResponse: @unchecked Sendable {}
    extension Services_Connect_V1_ListSessionsRequest: @unchecked Sendable {}
    extension Services_Connect_V1_ListSessionsResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "services.connect.v1"

extension Services_Connect_V1_VerificationType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "GOVERNMENT_ID"),
    ]
}

extension Services_Connect_V1_IDVSessionState: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "IDV_CREATED"),
        1: .same(proto: "IDV_INITIATED"),
        2: .same(proto: "IDV_AUTHENTICATING"),
        3: .same(proto: "IDV_IN_PROGRESS"),
        4: .same(proto: "IDV_SUCCESS"),
        5: .same(proto: "IDV_FAILED"),
    ]
}

extension Services_Connect_V1_VerificationState: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "VERIFICATION_PENDING"),
        1: .same(proto: "VERIFICATION_PENDING_REUSE"),
        2: .same(proto: "VERIFICATION_STARTED"),
        3: .same(proto: "VERIFICATION_SUCCESS"),
        4: .same(proto: "VERIFICATION_FAILED"),
    ]
}

extension Services_Connect_V1_SessionFailCode: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SESSION_FAIL_NONE"),
        1: .same(proto: "SESSION_FAIL_INTERNAL"),
        2: .same(proto: "SESSION_FAIL_VERIFICATION_FAILED"),
        3: .same(proto: "SESSION_FAIL_AUTHENTICATION"),
        4: .same(proto: "SESSION_FAIL_EXPIRED"),
        5: .same(proto: "SESSION_FAIL_USER_CANCELED"),
        6: .same(proto: "SESSION_FAIL_RP_CANCELED"),
    ]
}

extension Services_Connect_V1_VerificationFailCode: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "VERIFICATION_FAIL_NONE"),
        1: .same(proto: "VERIFICATION_FAIL_INTERNAL"),
        2: .same(proto: "VERIFICATION_FAIL_INVALID_IMAGE"),
        3: .same(proto: "VERIFICATION_FAIL_INAUTHENTIC"),
        4: .same(proto: "VERIFICATION_FAIL_UNSUPPORTED_DOCUMENT"),
    ]
}

extension Services_Connect_V1_SessionOrdering: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CREATED"),
        1: .same(proto: "UPDATED"),
        2: .same(proto: "STATE"),
    ]
}

extension Services_Connect_V1_IDVSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".IDVSession"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "client_token"),
        3: .same(proto: "state"),
        4: .same(proto: "verifications"),
        5: .standard(proto: "fail_code"),
        6: .standard(proto: "result_vp"),
        7: .same(proto: "created"),
        8: .same(proto: "updated"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &id)
            case 2: try decoder.decodeSingularStringField(value: &clientToken)
            case 3: try decoder.decodeSingularEnumField(value: &state)
            case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Services_Connect_V1_Verification>.self, value: &verifications)
            case 5: try decoder.decodeSingularEnumField(value: &_failCode)
            case 6: try decoder.decodeSingularStringField(value: &_resultVp)
            case 7: try decoder.decodeSingularFixed64Field(value: &created)
            case 8: try decoder.decodeSingularFixed64Field(value: &updated)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !clientToken.isEmpty {
            try visitor.visitSingularStringField(value: clientToken, fieldNumber: 2)
        }
        if state != .idvCreated {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 3)
        }
        if !verifications.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Services_Connect_V1_Verification>.self, value: verifications, fieldNumber: 4)
        }
        try { if let v = self._failCode {
            try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._resultVp {
            try visitor.visitSingularStringField(value: v, fieldNumber: 6)
        } }()
        if created != 0 {
            try visitor.visitSingularFixed64Field(value: created, fieldNumber: 7)
        }
        if updated != 0 {
            try visitor.visitSingularFixed64Field(value: updated, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_IDVSession, rhs: Services_Connect_V1_IDVSession) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.clientToken != rhs.clientToken { return false }
        if lhs.state != rhs.state { return false }
        if lhs.verifications != rhs.verifications { return false }
        if lhs._failCode != rhs._failCode { return false }
        if lhs._resultVp != rhs._resultVp { return false }
        if lhs.created != rhs.created { return false }
        if lhs.updated != rhs.updated { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_Verification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Verification"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "type"),
        3: .same(proto: "state"),
        4: .standard(proto: "fail_code"),
        5: .same(proto: "reused"),
        6: .same(proto: "begun"),
        7: .same(proto: "updated"),
        8: .standard(proto: "government_id_options"),
        9: .standard(proto: "normalized_government_id_data"),
    ]

    fileprivate class _StorageClass {
        var _id: String = .init()
        var _type: Services_Connect_V1_VerificationType = .governmentID
        var _state: Services_Connect_V1_VerificationState = .verificationPending
        var _failCode: Services_Connect_V1_VerificationFailCode?
        var _reused: Bool = false
        var _begun: UInt64 = 0
        var _updated: UInt64 = 0
        var _governmentIDOptions: Services_Connect_V1_GovernmentIDOptions?
        var _normalizedGovernmentIDData: Services_Connect_V1_NormalizedGovernmentIdData?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _id = source._id
            _type = source._type
            _state = source._state
            _failCode = source._failCode
            _reused = source._reused
            _begun = source._begun
            _updated = source._updated
            _governmentIDOptions = source._governmentIDOptions
            _normalizedGovernmentIDData = source._normalizedGovernmentIDData
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._id)
                case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
                case 3: try decoder.decodeSingularEnumField(value: &_storage._state)
                case 4: try decoder.decodeSingularEnumField(value: &_storage._failCode)
                case 5: try decoder.decodeSingularBoolField(value: &_storage._reused)
                case 6: try decoder.decodeSingularFixed64Field(value: &_storage._begun)
                case 7: try decoder.decodeSingularFixed64Field(value: &_storage._updated)
                case 8: try decoder.decodeSingularMessageField(value: &_storage._governmentIDOptions)
                case 9: try decoder.decodeSingularMessageField(value: &_storage._normalizedGovernmentIDData)
                default: break
                }
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._id.isEmpty {
                try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
            }
            if _storage._type != .governmentID {
                try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
            }
            if _storage._state != .verificationPending {
                try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
            }
            try { if let v = _storage._failCode {
                try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
            } }()
            if _storage._reused != false {
                try visitor.visitSingularBoolField(value: _storage._reused, fieldNumber: 5)
            }
            if _storage._begun != 0 {
                try visitor.visitSingularFixed64Field(value: _storage._begun, fieldNumber: 6)
            }
            if _storage._updated != 0 {
                try visitor.visitSingularFixed64Field(value: _storage._updated, fieldNumber: 7)
            }
            try { if let v = _storage._governmentIDOptions {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            } }()
            try { if let v = _storage._normalizedGovernmentIDData {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_Verification, rhs: Services_Connect_V1_Verification) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._id != rhs_storage._id { return false }
                if _storage._type != rhs_storage._type { return false }
                if _storage._state != rhs_storage._state { return false }
                if _storage._failCode != rhs_storage._failCode { return false }
                if _storage._reused != rhs_storage._reused { return false }
                if _storage._begun != rhs_storage._begun { return false }
                if _storage._updated != rhs_storage._updated { return false }
                if _storage._governmentIDOptions != rhs_storage._governmentIDOptions { return false }
                if _storage._normalizedGovernmentIDData != rhs_storage._normalizedGovernmentIDData { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_NormalizedGovernmentIdData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NormalizedGovernmentIdData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "id_number"),
        2: .standard(proto: "given_name"),
        3: .standard(proto: "family_name"),
        4: .same(proto: "address"),
        5: .standard(proto: "date_of_birth"),
        6: .same(proto: "country"),
        7: .standard(proto: "issue_date"),
        8: .standard(proto: "expiration_date"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &_idNumber)
            case 2: try decoder.decodeSingularStringField(value: &_givenName)
            case 3: try decoder.decodeSingularStringField(value: &_familyName)
            case 4: try decoder.decodeSingularStringField(value: &_address)
            case 5: try decoder.decodeSingularStringField(value: &_dateOfBirth)
            case 6: try decoder.decodeSingularStringField(value: &_country)
            case 7: try decoder.decodeSingularStringField(value: &_issueDate)
            case 8: try decoder.decodeSingularStringField(value: &_expirationDate)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._idNumber {
            try visitor.visitSingularStringField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._givenName {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._familyName {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._address {
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._dateOfBirth {
            try visitor.visitSingularStringField(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._country {
            try visitor.visitSingularStringField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._issueDate {
            try visitor.visitSingularStringField(value: v, fieldNumber: 7)
        } }()
        try { if let v = self._expirationDate {
            try visitor.visitSingularStringField(value: v, fieldNumber: 8)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_NormalizedGovernmentIdData, rhs: Services_Connect_V1_NormalizedGovernmentIdData) -> Bool {
        if lhs._idNumber != rhs._idNumber { return false }
        if lhs._givenName != rhs._givenName { return false }
        if lhs._familyName != rhs._familyName { return false }
        if lhs._address != rhs._address { return false }
        if lhs._dateOfBirth != rhs._dateOfBirth { return false }
        if lhs._country != rhs._country { return false }
        if lhs._issueDate != rhs._issueDate { return false }
        if lhs._expirationDate != rhs._expirationDate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_CreateSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateSessionRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "verifications"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &verifications)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !verifications.isEmpty {
            try visitor.visitRepeatedMessageField(value: verifications, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_CreateSessionRequest, rhs: Services_Connect_V1_CreateSessionRequest) -> Bool {
        if lhs.verifications != rhs.verifications { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_RequestedVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RequestedVerification"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .standard(proto: "government_id_options"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try {
                    var v: Services_Connect_V1_GovernmentIDOptions?
                    var hadOneofValue = false
                    if let current = self.options {
                        hadOneofValue = true
                        if case let .governmentIDOptions(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.options = .governmentIDOptions(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if type != .governmentID {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        try { if case let .governmentIDOptions(v)? = self.options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_RequestedVerification, rhs: Services_Connect_V1_RequestedVerification) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.options != rhs.options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_GovernmentIDOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GovernmentIDOptions"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "fields"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_fields)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._fields {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_GovernmentIDOptions, rhs: Services_Connect_V1_GovernmentIDOptions) -> Bool {
        if lhs._fields != rhs._fields { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_GovernmentIDFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GovernmentIDFields"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "id_number"),
        2: .standard(proto: "given_name"),
        3: .standard(proto: "family_name"),
        4: .same(proto: "address"),
        5: .standard(proto: "date_of_birth"),
        6: .same(proto: "country"),
        7: .standard(proto: "issue_date"),
        8: .standard(proto: "expiration_date"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &idNumber)
            case 2: try decoder.decodeSingularBoolField(value: &givenName)
            case 3: try decoder.decodeSingularBoolField(value: &familyName)
            case 4: try decoder.decodeSingularBoolField(value: &address)
            case 5: try decoder.decodeSingularBoolField(value: &dateOfBirth)
            case 6: try decoder.decodeSingularBoolField(value: &country)
            case 7: try decoder.decodeSingularBoolField(value: &issueDate)
            case 8: try decoder.decodeSingularBoolField(value: &expirationDate)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if idNumber != false {
            try visitor.visitSingularBoolField(value: idNumber, fieldNumber: 1)
        }
        if givenName != false {
            try visitor.visitSingularBoolField(value: givenName, fieldNumber: 2)
        }
        if familyName != false {
            try visitor.visitSingularBoolField(value: familyName, fieldNumber: 3)
        }
        if address != false {
            try visitor.visitSingularBoolField(value: address, fieldNumber: 4)
        }
        if dateOfBirth != false {
            try visitor.visitSingularBoolField(value: dateOfBirth, fieldNumber: 5)
        }
        if country != false {
            try visitor.visitSingularBoolField(value: country, fieldNumber: 6)
        }
        if issueDate != false {
            try visitor.visitSingularBoolField(value: issueDate, fieldNumber: 7)
        }
        if expirationDate != false {
            try visitor.visitSingularBoolField(value: expirationDate, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_GovernmentIDFields, rhs: Services_Connect_V1_GovernmentIDFields) -> Bool {
        if lhs.idNumber != rhs.idNumber { return false }
        if lhs.givenName != rhs.givenName { return false }
        if lhs.familyName != rhs.familyName { return false }
        if lhs.address != rhs.address { return false }
        if lhs.dateOfBirth != rhs.dateOfBirth { return false }
        if lhs.country != rhs.country { return false }
        if lhs.issueDate != rhs.issueDate { return false }
        if lhs.expirationDate != rhs.expirationDate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_CreateSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateSessionResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "session"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_session)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._session {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_CreateSessionResponse, rhs: Services_Connect_V1_CreateSessionResponse) -> Bool {
        if lhs._session != rhs._session { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_CancelSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CancelSessionRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "idv_session_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &idvSessionID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !idvSessionID.isEmpty {
            try visitor.visitSingularStringField(value: idvSessionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_CancelSessionRequest, rhs: Services_Connect_V1_CancelSessionRequest) -> Bool {
        if lhs.idvSessionID != rhs.idvSessionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_CancelSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CancelSessionResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "session"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_session)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._session {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_CancelSessionResponse, rhs: Services_Connect_V1_CancelSessionResponse) -> Bool {
        if lhs._session != rhs._session { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_GetSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSessionRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "idv_session_id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &idvSessionID)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !idvSessionID.isEmpty {
            try visitor.visitSingularStringField(value: idvSessionID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_GetSessionRequest, rhs: Services_Connect_V1_GetSessionRequest) -> Bool {
        if lhs.idvSessionID != rhs.idvSessionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_GetSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSessionResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "session"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_session)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._session {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_GetSessionResponse, rhs: Services_Connect_V1_GetSessionResponse) -> Bool {
        if lhs._session != rhs._session { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_ListSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListSessionsRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "order_by"),
        2: .standard(proto: "order_direction"),
        3: .standard(proto: "page_size"),
        4: .same(proto: "page"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &orderBy)
            case 2: try decoder.decodeSingularEnumField(value: &orderDirection)
            case 3: try decoder.decodeSingularInt32Field(value: &_pageSize)
            case 4: try decoder.decodeSingularInt32Field(value: &_page)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if orderBy != .created {
            try visitor.visitSingularEnumField(value: orderBy, fieldNumber: 1)
        }
        if orderDirection != .ascending {
            try visitor.visitSingularEnumField(value: orderDirection, fieldNumber: 2)
        }
        try { if let v = self._pageSize {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._page {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_ListSessionsRequest, rhs: Services_Connect_V1_ListSessionsRequest) -> Bool {
        if lhs.orderBy != rhs.orderBy { return false }
        if lhs.orderDirection != rhs.orderDirection { return false }
        if lhs._pageSize != rhs._pageSize { return false }
        if lhs._page != rhs._page { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Services_Connect_V1_ListSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListSessionsResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sessions"),
        2: .same(proto: "total"),
        3: .same(proto: "more"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &sessions)
            case 2: try decoder.decodeSingularInt32Field(value: &total)
            case 3: try decoder.decodeSingularBoolField(value: &more)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !sessions.isEmpty {
            try visitor.visitRepeatedMessageField(value: sessions, fieldNumber: 1)
        }
        if total != 0 {
            try visitor.visitSingularInt32Field(value: total, fieldNumber: 2)
        }
        if more != false {
            try visitor.visitSingularBoolField(value: more, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Services_Connect_V1_ListSessionsResponse, rhs: Services_Connect_V1_ListSessionsResponse) -> Bool {
        if lhs.sessions != rhs.sessions { return false }
        if lhs.total != rhs.total { return false }
        if lhs.more != rhs.more { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
